<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Schematic Highlighter — Docking + Tabs (v3.2f: annotation editor fix)</title>
<style>
:root{--bg:#0f1115;--panel:#161a22;--text:#e8eef7;--muted:#9fb0c3;--accent:#6bb2ff;--btn:#222838;--btnHover:#2b3347;--ok:#35c46a;--bad:#ff6b6b;--left:380px;--right:420px;--bottom:280px;--split:8px;
  --headerH: 60px;
}
*{box-sizing:border-box}html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}
header{padding:12px 16px;background:linear-gradient(180deg,#0d1016,#0f1219);border-bottom:1px solid #1f2533;box-shadow:0 2px 12px rgba(0,0,0,.35);position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:12px}
header .toolbar{display:flex;gap:8px;align-items:center}
header .toolbar-left{margin-right:8px}
header .toolbar-center{margin:0 auto}
header .toolbar-right{margin-left:8px}
header h1{margin:0;font-size:18px;font-weight:600;letter-spacing:.2px;flex:1}
header .toolbar button{appearance:none;background:var(--btn);color:var(--text);border:1px solid #2a3145;border-radius:8px;padding:6px 10px;font-size:13px;cursor:pointer}
header .toolbar button:hover{background:var(--btnHover)}
header .toolbar button.active{outline:2px solid #3a4a7a}
.dock{height:calc(100% - var(--headerH));display:grid;grid-template-columns:var(--left) var(--split) 1fr var(--split) var(--right);grid-template-rows:1fr var(--split) var(--bottom);grid-template-areas:"left splitL main splitR right" "left splitL splitB splitR right" "left splitL bottom splitR right";gap:0;padding:12px}
.panel{background:var(--panel);border:1px solid #1f2533;border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:12px;box-shadow:0 6px 24px rgba(0,0,0,.2);min-width:0;overflow:auto}
.panel h2{font-size:15px;margin:0 0 4px;color:var(--muted);font-weight:600}
.panel .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px}
.panel input[type=file],.panel input[type=range],.panel input[type=number],.panel input[type=text]{width:100%}
.panel output{font-variant-numeric:tabular-nums;min-width:46px;text-align:right;color:var(--accent)}
.panel button{appearance:none;background:var(--btn);color:var(--text);border:1px solid #2a3145;border-radius:8px;padding:8px 10px;font-size:14px;cursor:pointer;transition:background .15s ease,transform .015s ease}
.panel button:hover{background:var(--btnHover)}.panel button:active{transform:translateY(1px)}
.hint{font-size:12px;color:var(--muted);line-height:1.35}
.kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;background:#111521;border:1px solid #2a3145;border-radius:6px;padding:1px 6px;font-size:12px;color:#dbe6ff}
.drop{border:1px dashed #2a3145;border-radius:8px;padding:8px;text-align:center;color:#a7b6cc}.drop.drag{background:#111521;color:#cfe1ff}
.tabs{display:flex;gap:6px;flex-wrap:wrap}.tabs button{background:#121722;border:1px solid #263048;color:#cfe1ff;padding:6px 10px;border-radius:8px;font-size:13px;cursor:pointer}.tabs button.active{background:#1b2233;outline:2px solid #3a4a7a}
.tabpane{display:none}.tabpane.active{display:block}.sep{height:1px;background:#233049;margin:4px 0 8px}
.layerList{display:flex;flex-direction:column;gap:8px}
.layerItem{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px;border:1px solid #25324a;border-radius:8px;background:#0f141e}
.layerItem.active{border-color:#3a4a7a;background:#121a29}
.layerName{font-size:13px;color:#e6eefc}.eye{width:22px;height:22px;border-radius:6px;border:1px solid #2a3145;background:#0f141e;cursor:pointer}.eye.on::after{content:"👁";display:block;text-align:center;line-height:20px}.eye.off::after{content:"🚫";display:block;text-align:center;line-height:20px}
#consoleOut,#historyList{font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0c101a;border:1px solid #24304a;border-radius:8px;padding:8px;max-height:160px;overflow:auto;white-space:pre-wrap}
.footer{font-size:12px;color:var(--muted);text-align:center;margin-top:4px}
.splitter{background:transparent;position:relative;z-index:3}.splitter:hover::after{background:#2a3145}.splitter::after{content:"";position:absolute;background:#1b2233;border-radius:3px;opacity:.9}
.splitter.v{cursor:col-resize}.splitter.v.left{grid-area:splitL}.splitter.v.right{grid-area:splitR}.splitter.v::after{width:3px;top:12px;bottom:12px;left:calc(50% - 1.5px)}
.splitter.h{grid-area:splitB;cursor:row-resize position:relative; }.splitter.h::after{height:3px;left:12px;right:12px;top:calc(50% - 1.5px)}
#leftPanel{grid-area:left}#rightPanel{grid-area:right}#bottomPanel{grid-area:bottom}
.canvasWrap{grid-area:main;position:relative;background:#0b0d12;border:1px solid #1f2533;border-radius:10px;overflow:hidden;box-shadow:0 8px 30px rgba(0,0,0,.25);min-width:0;min-height:0}
canvas{position:absolute;inset:0;max-width:100%;max-height:100%;image-rendering:crisp-edges;image-rendering:pixelated;background:#fff}
#overlay{background:transparent!important;pointer-events:none}
.labelEditor{position:absolute;z-index:100;display:none;min-width:140px;border-radius:6px;border:1px solid #2a3145;background:#0f141f;color:#e6eefc;outline:none;padding:6px 8px;font:16px system-ui,sans-serif;box-shadow:0 4px 18px rgba(0,0,0,.35)}
.palette{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}.sym{border:1px solid #3a4a7a;border-radius:8px;background:#f4f7ff;padding:8px;display:flex;align-items:center;justify-content:center;cursor:grab;box-shadow:inset 0 0 0 1px rgba(255,255,255,.6)}.sym img{width:40px;height:40px}.sym:hover{background:#eaf1ff}.sym.dragging{opacity:.6}.symLabel{text-align:center;font-size:11px;color:#9fb0c3;margin-top:4px}
.pass{color:var(--ok)}.fail{color:var(--bad)}
.hide-left{--left:0}.hide-right{--right:0}.hide-bottom{--bottom:0}.hide-left #leftPanel,.hide-left .splitter.v.left{display:none}.hide-right #rightPanel,.hide-right .splitter.v.right{display:none}.hide-bottom #bottomPanel,.hide-bottom .splitter.h{display:none}
#leftPanel #panToggle, #leftPanel #highlightToggle, #leftPanel #textModeBtn, #leftPanel #eraserToggle, #leftPanel #lineToggle, #leftPanel #netLabelBtn, #leftPanel #contToggleBtn, #leftPanel #toolPan, #leftPanel #toolHighlight, #leftPanel #toolText, #leftPanel #toolEraser, #leftPanel #toolLine, #leftPanel #toolNet, #leftPanel #toolCont{display:none !important}
#leftPanel .toolstrip, #leftPanel [data-section='tools'], #leftPanel .tools-group{display:none !important}
#leftPanel h2, #leftPanel h3 { }

/* Cleanup markers overlay style (drawn on canvas) */


/* Retype selection rectangle */
.retype-rect{
  position:absolute; border:1.5px dashed rgba(107,178,255,.9);
  background:rgba(107,178,255,.12); pointer-events:none; z-index:6;
}


/* --- Preset chips --- */
.chip{background:var(--btn);border:1px solid rgba(255,255,255,.08);padding:6px 10px;border-radius:999px;cursor:pointer}
.chip:hover{background:var(--btnHover)}
/* --- Progress modal --- */
#progressModal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:9999}
#progressCard{background:var(--panel);padding:16px 18px;border-radius:12px;min-width:280px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
#progressTitle{font-weight:600;margin:0 0 10px 0}
#progressText{font-size:13px;opacity:.9;margin:4px 0 10px 0}
.progressBar{height:10px;background:#222838;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.07)}
.progressBar > div{height:100%;width:0%}


/* --- Toolbar iconography --- */
header .toolbar button{display:flex;align-items:center;gap:8px;padding:8px 10px}
header .toolbar .ico{width:18px;height:18px;display:inline-grid;place-items:center;line-height:0}
header .toolbar .ico svg{width:18px;height:18px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
header .toolbar .lbl{white-space:nowrap}
@media (max-width: 900px){
  header .toolbar .lbl{display:none}
  header .toolbar button{padding:8px}
}


/* --- Two-row toolbar layout --- */
header .toolbar-center{
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:8px 10px;
  max-width:100%;
}
/* Keep left/right compact; allow center to grow vertically */
header .toolbar-left, header .toolbar-right{flex:0 0 auto}


/* --- Balanced two-row center toolbar --- */
header .toolbar-center{
  display:grid;
  grid-auto-flow: column;
  grid-template-rows: repeat(2, auto);
  grid-auto-columns: max-content;
  justify-content:center;
  align-content:start;
  gap:8px 10px;
  max-width:100%;
  margin: 0 auto;
}


/* --- Panel chevrons + reveal handles --- */
.panel{position:relative}
.chev{position:absolute; display:grid; place-items:center; width:26px; height:42px;
  background:var(--btn); border:1px solid #2a3145; border-radius:10px; opacity:.9; cursor:pointer;
  box-shadow:0 6px 16px rgba(0,0,0,.25); transition:opacity .2s, transform .2s z-index:50; }
.chev:hover{opacity:1}
/* within panels */
#leftPanel .chev-left{ right:-10px; top:50%; transform:translateY(-50%); }
#rightPanel .chev-right{ left:-10px; top:50%; transform:translateY(-50%); }
#bottomPanel .chev-bottom{ left:50%; top:-12px; transform:translate(-50%, -0%); height:26px }
/* small caret icons */
.chev svg, .reveal svg{ width:18px; height:18px; stroke:currentColor; fill:none; stroke-width:2; stroke-linecap:round; stroke-linejoin:round }

/* edge reveal handles (visible when a side is hidden) */
.reveal{position:absolute; display:none; place-items:center; width:22px; height:46px;
  background:var(--btn); border:1px solid #2a3145; border-radius:10px; cursor:pointer; opacity:.85 z-index:50; }
.reveal:hover{opacity:1}
.reveal.left{ left:6px; top:calc(var(--headerH) + 50%); transform:translateY(-50%); }
.reveal.right{ right:6px; top:calc(var(--headerH) + 50%); transform:translateY(-50%); }
.reveal.bottom{ left:50%; bottom:8px; transform:translateX(-50%); height:22px }

.hide-left .reveal.left{ display:grid }
.hide-right .reveal.right{ display:grid }
.hide-bottom .reveal.bottom{ display:grid }


/* --- Header title removed; let center toolbar take space --- */
header{justify-content:center}
header .toolbar-center{margin:0 auto; flex: 1 1 auto}


/* --- Compact header after title removal --- */
header{padding:8px 12px}


/* --- Stronger bottom chevron --- */
#splitBottom{position:relative}
#chevBottomSplit{width:44px;height:28px;border-radius:999px;background:var(--btn);border:1px solid #2a3145;box-shadow:0 6px 16px rgba(0,0,0,.3)}
#chevBottomSplit .arrow{transition:transform .15s ease}
/* flip when bottom is hidden */
.hide-bottom #chevBottomSplit .arrow{transform:rotate(180deg)}
/* Also flip panel-anchored one */
.hide-bottom #bottomPanel .chev-bottom .arrow{transform:rotate(180deg)}


/* --- Patch: actions row --- */
.net-chev-controls .row button{padding:6px 10px;border-radius:8px;border:1px solid #273148;background:#131a27;color:#e8eef7}
.net-chev-controls .row button:hover{background:#172136}

/* --- Patch: Nets panel Chevron controls layout (pinned) --- */
.net-chev-controls{margin:12px 0 14px 0;padding:12px;border:1px solid #222a3a;border-radius:12px;background:#101521}
.net-chev-controls .hdr{font-weight:600;margin-bottom:8px;opacity:.9}
.net-chev-controls .toggles{display:flex;gap:18px;flex-wrap:wrap;margin-bottom:8px}
.net-chev-controls .grid3{display:grid;grid-template-columns: 110px 1fr 42px;gap:8px;align-items:center;margin-bottom:8px}
.net-chev-controls .grid2{display:grid;grid-template-columns: 110px 1fr;gap:8px;align-items:center}
.net-chev-controls input[type="range"]{width:100%}
.net-chev-controls output{justify-self:end;min-width:2ch;text-align:right;opacity:.85}
.net-chev-controls select{width:100%}
.net-chev-controls .row button{padding:6px 10px;border-radius:8px;border:1px solid #273148;background:#131a27;color:#e8eef7}
.net-chev-controls .row button:hover{background:#172136}
</style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
<header>
  <div class="toolbar toolbar-left" role="toolbar" aria-label="Panels">
    <button id="toggleLeft" class="active">Left</button>
    <button id="toggleRight" class="active">Right</button>
    <button id="toggleBottom" class="active">Bottom</button>
  </div>
  <div class="toolbar toolbar-center" role="toolbar" aria-label="Tools (Top)">
    <button id="topPan">Pan (P)</button>
    <button id="topHighlight" class="active">Highlight (H)</button>
    <button id="topText">Text (T)</button>
    <button id="topEraser">Eraser (E)</button>
    <button id="topLine">Line (L)</button>
    <button id="topNet">Net (N)</button>
    <button id="topCont">Continuity (C)</button>
  
      <button id="cleanupToggle" title="Cleanup mode (redraw black stroke over traced lines)">Cleanup</button>
      <button id="cleanupFindBtn" title="Find opens/tees">Find Opens/Tees</button>
      <button id="cleanupSettingsBtn" title="Cleanup settings">⚙</button>

      <button id="retypeToggle" title="Retype (R): box old text then type new">Retype (R)</button>
    <button id="topArrows" title="Manual Arrows">Arrows</button>
  </div>
  <div class="toolbar toolbar-right" role="toolbar" aria-label="Actions">
    <button id="fit">Fit</button>
    <button id="clear">Clear</button>
    <button id="download">PNG</button>
    <button id="scanPolishBtn" title="One-click: auto threshold → cleanup → text cleanup → auto-label VCC/GND">Scan Polish</button>
    <button id="saveProject">Save Project</button>
    <button id="openProjectBtn">Open</button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
    <input id="openProject" type="file" accept="application/json" style="display:none" />
  </div>

</header>

<div id="dock" class="dock">

  <button id="revealLeft" class="reveal left" title="Show left panel" aria-label="Show left panel">
    <svg viewBox="0 0 24 24"><polyline points="14 6 8 12 14 18"/></svg>
  </button>
  <button id="revealRight" class="reveal right" title="Show right panel" aria-label="Show right panel">
    <svg viewBox="0 0 24 24"><polyline points="10 6 16 12 10 18"/></svg>
  </button>
  <button id="revealBottom" class="reveal bottom" title="Show bottom panel" aria-label="Show bottom panel">
    <svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg>
  </button>

  <aside id="leftPanel" class="panel">
  <button id="chevLeft" class="chev chev-left" title="Hide left panel" aria-label="Hide left panel">
  <svg viewBox="0 0 24 24"><polyline points="14 6 8 12 14 18"/></svg>
</button>
    <div>
      <h2>1) Load schematic image</h2>
      <div class="row"><input id="file" type="file" accept="image/*"></div>
      <div id="drop" class="drop">…or drag & drop an image here</div>
      <div class="row" style="margin-top:6px;gap:6px;grid-template-columns:auto 1fr;">
        <button id="loadSample">Load sample</button>
        <div class="hint">PNG (black lines on white) gives best results. PDFs need to be exported to an image first.</div>
      </div>
    </div>

    <div>
      <h2>2) Tools</h2>
      <div class="row" style="grid-template-columns:repeat(3, auto) 1fr; gap:8px; align-items:center;">
        <button id="panToggle">Pan (P)</button>
        <button id="highlightToggle" class="active">Highlight (H)</button>
        <button id="textMode">Text (T)</button>
        <button id="eraserToggle">Eraser (E)</button>
        <button id="lineToggle">Line (L)</button>
      </div>
      <div class="row" style="grid-template-columns:repeat(2, auto) 1fr; gap:8px; align-items:center; margin-top:6px;">
        <button id="netLabelMode">Net Label (N)</button>
        <button id="contToggle">Continuity (C)</button>
        <div class="hint">Net Label: click a wire to name it. Continuity: pick two pins → pass/fail.</div>
      </div>
      <div class="row"><label for="eraserSize">Eraser size (px)</label><output id="eraserSizeVal">10</output></div>
      <input id="eraserSize" type="range" min="2" max="48" step="1" value="10">
      <div class="hint">Eraser clears the <b>active layer</b>. Hold mouse and scrub to remove highlight pixels. Use <b>Line</b> to draw straight highlight segments.</div>
    </div>

    <div>
      <h2>Tracing</h2>
      <div class="hint">Click near a thin black line to trace the connected stroke. <b>Middle-click</b> or hold <span class="kbd">Space</span> to pan. <b>Wheel = zoom</b>. Shift+Click to clear first.</div>
      <label class="inline" style="display:flex;align-items:center;gap:8px;"><input type="checkbox" id="segmentMode" checked> Stop at junctions (segment between tees/symbols)</label>
    </div>

    <div>
      <h2>Threshold</h2>
      <label class="inline"><input type="checkbox" id="autoThresh" checked> Auto-detect dark-line threshold</label>
      <div class="row"><label for="thresh">Manual threshold</label><output id="threshVal">120</output></div>
      <input id="thresh" type="range" min="0" max="255" value="120" step="1">
      <div class="row" style="grid-template-columns:auto auto 1fr; gap:8px;">
        <button id="analyze">Analyze</button>
        <div class="hint">Auto picks a value using Otsu on luminance histogram.</div>
      </div>
    </div>

    <div>
      <h2>Performance</h2>
      <label class="inline"><input type="checkbox" id="autoDown" checked> Auto-downscale large images</label>
      <div class="row"><label for="maxDim">Max dimension (px)</label><output id="maxDimVal">4096</output></div>
      <input id="maxDim" type="number" min="512" max="8192" step="128" value="4096">
    </div>

    <div class="footer">All local. No uploads.</div>
  </aside>

  <div id="splitLeft" class="splitter v left"></div>

  <main class="canvasWrap">
    <canvas id="view" width="1280" height="800"></canvas>
    <canvas id="overlay" width="1280" height="800"></canvas>
    <canvas id="arrowsCanvas" width="1280" height="800" style="pointer-events:none;background:transparent"></canvas>
    <input id="labelEditor" class="labelEditor" placeholder="Type and Enter…" />
  </main>

  <div id="splitRight" class="splitter v right"></div>

  <aside id="rightPanel" class="panel">
  <button id="chevRight" class="chev chev-right" title="Hide right panel" aria-label="Hide right panel">
  <svg viewBox="0 0 24 24"><polyline points="10 6 16 12 10 18"/></svg>
</button>
    <div class="tabs" id="rightTabs">
      <button data-tab="props" class="active">Properties</button>
      <button data-tab="layers">Layers</button>
      <button data-tab="symbols">Symbols</button>
      <button data-tab="nets">Nets</button>
    
      <button data-tab="cleanup">Cleanup</button>
    
      <button data-tab="text">Text</button>
    </div>
    <div class="sep"></div>

    <section id="tab-props" class="tabpane active">
      <div>
        <h2>Text annotations</h2>
        <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px; align-items:center;">
          <label class="inline" style="gap:6px;">Color <input id="labelColor" type="color" value="#ffff00"></label>
          <label class="inline" style="gap:6px;">Size <output id="labelSizeVal">18</output>px</label>
        </div>
        <input id="labelSize" type="range" min="10" max="48" value="18" step="1">
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="showAnnotations" type="checkbox" checked> Show annotations</label>
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="showNetLabels" type="checkbox" checked> Show net labels</label>
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="contFree" type="checkbox"> Free continuity (click any two points)</label>
      </div>

      <div>
        <h2>Highlight & Limits</h2>
        <div class="row"><label for="snap">Snap radius (px)</label><output id="snapVal">6</output></div>
        <input id="snap" type="range" min="0" max="20" value="6" step="1">
        <div class="row"><label for="alpha">Default opacity</label><output id="alphaVal">0.70</output></div>
        <input id="alpha" type="range" min="0" max="100" value="70" step="1">
        <div class="row"><label for="color">Default color</label><input id="color" type="color" value="#ff0000"></div>
        <div class="row" style="grid-template-columns:auto 1fr;">
          <button id="autoColor">Auto line color (A)</button>
          <div></div>
        </div>
        <div class="row"><label for="thickness">Highlight thickness (px)</label><output id="thicknessVal">6</output></div>
        <input id="thickness" type="range" min="1" max="24" value="6" step="1">
        <div class="row"><label for="limit">Pixel limit (×1000)</label><output id="limitVal">600</output></div>
        <input id="limit" type="range" min="20" max="5000" value="600" step="20">
        <div class="row" style="grid-template-columns:auto auto 1fr;">
          <button id="clearActive">Clear active layer</button>
          <button id="syncLayerStyle">Apply defaults to active layer</button>
        </div>
      </div>

      <div>
        <h2>Zoom & Pan</h2>
        <div class="row"><label for="zoom">Zoom</label><output id="zoomVal">100%</output></div>
        <input id="zoom" type="range" min="10" max="300" value="100" step="1">
        <div class="hint" id="meta"></div>
      </div>
    </section>

    <section id="tab-layers" class="tabpane">
      <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px;">
        <button id="addLayer">+ Layer</button>
        <button id="delLayer">Delete</button>
        <button id="dupLayer">Duplicate</button>
      </div>
      <div class="layerList" id="layerList"></div>
      <div class="hint">Tips: click a layer row to activate it. Eye toggles visibility. Color/opacity affect rendering.</div>
    </section>

    <section id="tab-symbols" class="tabpane">
      <div>
        <h2>Palette (drag onto canvas)</h2>
        <div class="palette" id="palette"></div>
        <div class="hint">Drag one of the symbols onto the canvas. Click to select; drag to move; <span class="kbd">Delete</span> to remove; <span class="kbd">[</span>/<span class="kbd">]</span> to rotate; <span class="kbd">+</span>/<span class="kbd">-</span> to scale.</div>
      </div>
      <div class="sep"></div>
      <div>
        <h2>Placement</h2>
        <label style="display:flex;gap:8px;align-items:center;"><input id="snapGrid" type="checkbox" checked> Snap to grid</label>
        <div class="row"><label for="gridSize">Grid size (px)</label><output id="gridSizeVal">10</output></div>
        <input id="gridSize" type="range" min="4" max="40" step="1" value="10">
        <label style="display:flex;gap:8px;align-items:center;"><input id="snapLine" type="checkbox"> Snap to existing lines</label>
        <label style="display:flex;gap:8px;align-items:center;"><input type="checkbox" id="symLockLayer"> Lock moves to active layer</label>
      </div>
      <div class="sep"></div>
      <div>
        <h2>Selected symbol</h2>
        <div class="row"><label for="symSize">Size (px)</label><output id="symSizeVal">64</output></div>
        <input id="symSize" type="range" min="20" max="200" value="64" step="2">
        <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px;">
          <button id="rotL">⟲ Rotate</button>
          <button id="rotR">⟳ Rotate</button>
          <button id="delSym">Delete</button>
        </div>
        <div class="row"><label>Symbol color</label><input id="symColor" type="color" value="#000000"></div>
        <div class="row"><label>Label text</label><input id="symLabel" type="text" placeholder="e.g., R1"></div>
        <div class="row"><label>Label size (px)</label><output id="symLabelSizeVal">16</output></div>
        <input id="symLabelSize" type="range" min="10" max="36" step="1" value="16">
        <div class="row"><label>Label color</label><input id="symLabelColor" type="color" value="#000000"></div>
      </div>
    </section>

    <section id="tab-nets" class="tabpane">
<!-- Patch: Arrows & Label (pinned at top of Nets) -->
<div id="arrowsControlsPinned" class="net-chev-controls">
  <div class="hdr">Arrows &amp; Label</div>
<script>
// Keep active net's arrows config synced with pinned controls
(function(){
  const ids = ['chkChevronEnable','chkChevronMarch','chkLabelShow','rngChevronSpace','rngChevronSize','rngChevronSpeed','rngLabelSize','selArrowStyle','rngStartOffset','chkAutoDensity','colArrow','colLabelBg','colLabelFg'];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if(!el) return;
    const ev = (el.tagName==='SELECT'||el.type==='color'||el.type==='text') ? 'change' : 'input';
    el.addEventListener(ev, ()=>{
      if(activeNet<0 || activeNet>=netLabels.length) return;
      const cfg = readArrowsPinnedUI();
      netLabels[activeNet].arrows = cfg;
      applyArrowsForActiveNet();
    });
  });
})();
</script>

  <div class="row toggles">
    <label><input type="checkbox" id="chkChevronEnable" checked> Arrows</label>
    <label><input type="checkbox" id="chkChevronMarch" checked> Marching</label>
    <label><input type="checkbox" id="chkLabelShow" checked> Label at start</label>
  </div>
  <div class="grid3">
    <div>Spacing</div><input type="range" id="rngChevronSpace" min="16" max="160" value="52"><output id="outChevronSpace">52</output>
    <div>Arrow Size</div><input type="range" id="rngChevronSize" min="10" max="48" value="18"><output id="outChevronSize">18</output>
    <div>Speed</div><input type="range" id="rngChevronSpeed" min="0" max="4" value="2"><output id="outChevronSpeed">2</output>
    <div>Label Size</div><input type="range" id="rngLabelSize" min="10" max="28" value="14"><output id="outLabelSize">14</output>
  </div>
  <div class="grid3">
    <div>Style</div>
    <select id="selArrowStyle">
      <option value="triangle" selected>Triangle</option>
      <option value="chevron">Chevron “»”</option>
      <option value="dots">Dots</option>
    </select>
    <span></span>
    <div>Start Offset</div><input type="range" id="rngStartOffset" min="0" max="120" value="12"><output id="outStartOffset">12</output>
    <div>Auto Density</div><label><input type="checkbox" id="chkAutoDensity" checked> Tight bends = denser arrows</label><span></span>
  </div>
  <div class="grid2">
    <div>Arrow Color</div><input type="color" id="colArrow" value="#6bb2ff">
    <div>Label BG</div><input type="color" id="colLabelBg" value="#141820">
    <div>Label Text</div><input type="color" id="colLabelFg" value="#e8eef7">
  </div>
  <div class="row" style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
    <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="chkAutoFromHighlight" checked> <span>Auto from highlight</span></label>
    <button id="btnApplyFromHighlight">Apply now</button>
    <button id="btnTestArrows">▶ Test arrows</button>
  </div>
</div>

      <div class="row" style="grid-template-columns:auto auto 1fr auto; gap:8px;">
        <button id="addNet">+ Net</button>
        <button id="delNet">Delete</button>
        <div></div>
        <button id="exportNets">Export JSON</button>
      </div>
      <div class="layerList" id="netsList"></div>
      <div class="hint">Click a net to edit. “+ Net” switches to Net Label mode; then click a wire to create it. Use the Zoom button on a row to center on that net.</div>
    </section>
    <section id="tab-cleanup" class="tabpane">
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupEnabled"> Enable cleanup overlay</label>
      </div>
      <div class="group">
        <label class="inline">Stroke thickness <input type="range" id="cleanupThickness" min="0.5" max="12" step="0.25" value="0.75"></label>
        <span id="cleanupThicknessVal">0.75 px</span>
      </div>
      <div class="group">
        <label class="inline">Bridge gaps (blur px) <input type="range" id="cleanupBridge" min="0" max="6" step="0.25" value="0.5"></label>
        <span id="cleanupBridgeVal">0.5 px</span>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap">
        <span class="muted" style="opacity:.85">Presets:</span>
        <button class="chip" id="cleanupPresetFine" title="0.75 px / 0.5 px">Fine</button>
        <button class="chip" id="cleanupPresetNormal" title="1.5 px / 1.0 px">Normal</button>
        <button class="chip" id="cleanupPresetBold" title="2.5 px / 1.5 px">Bold</button>
      </div>
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupAuto" checked> Auto after trace</label>
      </div>
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupIgnoreSymbols"> Ignore symbols while cleaning</label>
      </div>
      <div class="row" style="gap:8px;">
        <button id="cleanupRunNow">Run cleanup now</button>
        <button id="cleanupFindBtn">Find Opens/Tees</button>
        <button id="cleanupClearMarkers" title="Clear markers">Clear markers</button>
      </div>
      <div class="group" style="margin-top:8px;">
        <label class="inline"><input type="checkbox" id="junctionNormalize"> Normalize junction dots</label>
      </div>
      <div class="group">
        <label class="inline">Dot radius <input type="range" id="junctionRadius" min="2" max="14" step="0.5" value="6"></label>
        <span id="junctionRadiusVal">6 px</span>
      </div>

      <p class="muted">Cleanup draws a constant-thickness black stroke along traced masks, bridging tiny gaps and painting over symbols/text.</p>
    </section>
    <section id="tab-text" class="tabpane">
      <h2>Text cleanup</h2>
      <div class="group">
        <label class="inline"><input type="checkbox" id="textCleanEnabled" checked> Enable text-only cleanup</label>
      </div>
      <div class="group">
        <label class="inline">Tile size <input type="range" id="textTile" min="12" max="64" step="4" value="28"></label>
        <span id="textTileVal">28 px</span>
      </div>
      <div class="group">
        <label class="inline">Local offset (C) <input type="range" id="textC" min="0" max="40" step="1" value="12"></label>
        <span id="textCVal">12</span>
      </div>
      <div class="group">
        <label class="inline">Close radius <input type="range" id="textClose" min="0" max="2" step="0.25" value="0.5"></label>
        <span id="textCloseVal">0.5 px</span>
      </div>
      <div class="group">
        <label class="inline">Despeckle (neighbors) <input type="range" id="textSpeckle" min="0" max="4" step="1" value="2"></label>
        <span id="textSpeckleVal">2</span>
      </div>
      <div class="group">
        <label class="inline">Exclude traced lines <input type="checkbox" id="textExcludeLines" checked></label>
      </div>
      <div class="row" style="gap:8px;">
        <button id="textBuildBtn">Run Now</button>
        <button id="textClearBtn">Clear</button>
      </div>
      <p class="muted">      <div class="row" style="gap:8px; margin-top:8px;">
        <button id="ocrSelectBtn" title="Drag a box to OCR (O)">OCR selection</button>
        <button id="ocrPageBtn" title="OCR the entire image (slower)">OCR page</button>
        <label class="inline" style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="ocrAttachNet" checked> Attach OCR near wires as Net Label
        </label>
      </div>
This pass cleans only raster text: adaptive binarize, close tiny gaps, drop speckle, and draw crisp black text over a white underlay. Use “Retype (R)” to replace text manually.</p>
      <h3 style="margin-top:10px;">Retype patches</h3>
      <div class="row" style="gap:8px;">
        <button id="retypeToggle2">Retype Mode</button>
        <button id="clearRetypePatches">Clear Patches</button>
      </div>
    </section>


  </aside>

  <div id="splitBottom" class="splitter h">

    <button id="chevBottomSplit" class="chev chev-bottom" title="Hide bottom panel" aria-label="Hide bottom panel" style="left:50%; top:50%; transform:translate(-50%,-50%); height:22px; width:36px;"><span class="arrow"><svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg></span></button>
</div>
  <section id="bottomPanel" class="panel">
  <button id="chevBottom" class="chev chev-bottom" title="Hide bottom panel" aria-label="Hide bottom panel"><span class="arrow"><svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg></span></button>
    <div class="tabs" id="bottomTabs">
      <button data-tab="history" class="active">History</button>
      <button data-tab="console">Console</button>
      <button data-tab="tests">Self-tests</button>
    </div>
    <div class="sep"></div>

    <section id="tab-history" class="tabpane active">
      <div class="row" style="grid-template-columns:auto 1fr;gap:8px;align-items:center;">
        <h2 style="margin:0;">History</h2>
        <div style="text-align:right;"><button id="clearHistory">Clear history</button></div>
      </div>
      <div id="historyList"></div>
    </section>

    <section id="tab-console" class="tabpane">
      <div class="row" style="grid-template-columns:1fr auto;gap:8px;">
        <input id="consoleIn" placeholder="Type a command (help, clear, stats, layers, symbols, nets)" />
        <button id="consoleRun">Run</button>
      </div>
      <pre id="consoleOut"></pre>
    </section>

    <section id="tab-tests" class="tabpane">
      <div class="row" style="grid-template-columns:auto 1fr;gap:8px;align-items:center;">
        <h2 style="margin:0;">Self-tests</h2>
        <div style="text-align:right;"><button id="runTests">Run self-test</button></div>
      </div>
      <div class="hint">Quick check that tracing + overlay + autos are working.</div>
      <div id="testLog"></div>
    </section>
  </section>
</div>

<script>
// ===== Sample + symbols =====
function createSampleSvg(){
  const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='800' viewBox='0 0 1200 800'>
    <rect width='100%' height='100%' fill='white'/>
    <g stroke='black' stroke-width='3' fill='none'>
      <line x1='50' y1='100' x2='1150' y2='100'/>
      <line x1='200' y1='100' x2='200' y2='700'/>
      <rect x='300' y='300' width='220' height='160'/>
      <circle cx='780' cy='420' r='90'/>
      <polyline points='980,200 1030,200 1030,260 980,260 980,200' />
      <line x1='980' y1='230' x2='1030' y2='230'/>
    </g>
  </svg>`;
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
}
const SAMPLE_URL = createSampleSvg();

const SYMBOL_SVGS = {
  resistor:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 40'><path d='M0 20 H20 L30 10 L40 30 L50 10 L60 30 L70 10 L80 30 L90 10 L100 30 L110 20 H120' stroke='black' stroke-width='4' fill='none'/></svg>`,
  capacitor:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 40'><path d='M0 20 H50 M70 20 H120' stroke='black' stroke-width='4' fill='none'/><path d='M50 8 V32 M70 8 V32' stroke='black' stroke-width='4'/></svg>`,
  diode:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 40'><path d='M0 20 H30' stroke='black' stroke-width='4'/><path d='M30 10 L70 20 L30 30 Z' fill='black'/><path d='M70 8 V32' stroke='black' stroke-width='4'/><path d='M70 20 H120' stroke='black' stroke-width='4'/></svg>`,
  led:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 60'><path d='M0 30 H30' stroke='black' stroke-width='4'/><path d='M30 15 L70 30 L30 45 Z' fill='black'/><path d='M70 10 V50' stroke='black' stroke-width='4'/><path d='M70 30 H140' stroke='black' stroke-width='4'/><path d='M95 8 l12 -12 M98 20 l12 -12' stroke='black' stroke-width='3'/></svg>`,
  inductor:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 160 40'><path d='M0 20 H20' stroke='black' stroke-width='4' fill='none'/><path d='M20 20 c10 -20 30 -20 40 0 c10 -20 30 -20 40 0 c10 -20 30 -20 40 0' stroke='black' stroke-width='4' fill='none'/><path d='M140 20 H160' stroke='black' stroke-width='4'/></svg>`,
  ground:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 60'><path d='M40 0 V20' stroke='black' stroke-width='4'/><path d='M20 28 H60 M26 36 H54 M32 44 H48' stroke='black' stroke-width='4'/></svg>`,
  opamp:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 100'><path d='M20 50 L100 10 V90 Z' fill='none' stroke='black' stroke-width='4'/><path d='M0 30 H40 M0 70 H40' stroke='black' stroke-width='4'/><path d='M100 50 H140' stroke='black' stroke-width='4'/></svg>`,
  capacitor_polarized:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 140 60'><path d='M0 30 H60 M80 30 H140' stroke='black' stroke-width='4'/><path d='M60 10 V50 M80 10 V50' stroke='black' stroke-width='4'/><path d='M90 12 h10 m-5 -5 v10' stroke='black' stroke-width='3'/></svg>`,
  text:`<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 80 80'><rect x='3' y='3' width='74' height='74' rx='10' ry='10' fill='white' stroke='black' stroke-width='4'/><path d='M20 28 H60 M40 28 V60' stroke='black' stroke-width='6' stroke-linecap='round'/></svg>`
};
const symbolImages = {}; for (const [k,svg] of Object.entries(SYMBOL_SVGS)){ const img=new Image(); img.src='data:image/svg+xml;utf8,'+encodeURIComponent(svg); symbolImages[k]=img; }
const tintCanvas=document.createElement('canvas'); const tintCtx=tintCanvas.getContext('2d');

// ===== DOM refs =====
const fileInput=document.getElementById('file'); const drop=document.getElementById('drop'); const loadSample=document.getElementById('loadSample');
const fitBtn=document.getElementById('fit'); const runTestsBtn=document.getElementById('runTests'); const testLog=document.getElementById('testLog');
const view=document.getElementById('view'); const overlay=document.getElementById('overlay');
const vctx=view.getContext('2d',{willReadFrequently:true}); const octx=overlay.getContext('2d',{willReadFrequently:true});

// --- Arrows canvas setup (added) ---
const arrowsCanvas = document.getElementById('arrowsCanvas');
if (arrowsCanvas) {
  const arrowsCtx = arrowsCanvas.getContext('2d', { willReadFrequently: true });
  window.arrowsCanvas = arrowsCanvas;
  window.arrowsCtx = arrowsCtx;
}
// -----------------------------------
const autoThresh=document.getElementById('autoThresh'); const analyzeBtn=document.getElementById('analyze'); const segmentMode=document.getElementById('segmentMode'); const panToggle=document.getElementById('panToggle');
const thresh=document.getElementById('thresh'); const threshVal=document.getElementById('threshVal');
const autoDown=document.getElementById('autoDown'); const maxDim=document.getElementById('maxDim'); const maxDimVal=document.getElementById('maxDimVal');
const snap=document.getElementById('snap'); const snapVal=document.getElementById('snapVal'); const alpha=document.getElementById('alpha'); const alphaVal=document.getElementById('alphaVal');
const color=document.getElementById('color'); const autoColorBtn=document.getElementById('autoColor');
const thickness=document.getElementById('thickness'); const thicknessVal=document.getElementById('thicknessVal'); const limit=document.getElementById('limit'); const limitVal=document.getElementById('limitVal');
const zoom=document.getElementById('zoom'); const zoomVal=document.getElementById('zoomVal'); const clearBtn=document.getElementById('clear'); const meta=document.getElementById('meta');
const highlightToggle=document.getElementById('highlightToggle'); const textModeBtn=document.getElementById('textMode'); const eraserToggle=document.getElementById('eraserToggle'); const lineToggle=document.getElementById('lineToggle');
const eraserSize=document.getElementById('eraserSize'); const eraserSizeVal=document.getElementById('eraserSizeVal');
const labelColor=document.getElementById('labelColor'); const labelSize=document.getElementById('labelSize'); const labelSizeVal=document.getElementById('labelSizeVal');
const labelEditor=document.getElementById('labelEditor'); const showAnnotationsChk=document.getElementById('showAnnotations'); const showNetLabelsChk=document.getElementById('showNetLabels');
const clearActiveBtn=document.getElementById('clearActive'); const syncLayerStyleBtn=document.getElementById('syncLayerStyle');
const netLabelBtn=document.getElementById('netLabelMode'); const contToggleBtn=document.getElementById('contToggle');
const rightTabs=document.getElementById('rightTabs'); const bottomTabs=document.getElementById('bottomTabs');
const addLayerBtn=document.getElementById('addLayer'); const delLayerBtn=document.getElementById('delLayer'); const dupLayerBtn=document.getElementById('dupLayer'); const layerList=document.getElementById('layerList');
const consoleIn=document.getElementById('consoleIn'); const consoleRun=document.getElementById('consoleRun'); const consoleOut=document.getElementById('consoleOut'); const historyList=document.getElementById('historyList'); const clearHistoryBtn=document.getElementById('clearHistory');
const toggleLeftBtn=document.getElementById('toggleLeft'); const toggleRightBtn=document.getElementById('toggleRight'); const toggleBottomBtn=document.getElementById('toggleBottom');
const dock=document.getElementById('dock'); const splitLeft=document.getElementById('splitLeft'); const splitRight=document.getElementById('splitRight'); const splitBottom=document.getElementById('splitBottom');
const palette=document.getElementById('palette'); const symSize=document.getElementById('symSize'); const symSizeVal=document.getElementById('symSizeVal'); const rotL=document.getElementById('rotL'); const rotR=document.getElementById('rotR'); const delSym=document.getElementById('delSym');
const symLockLayer=document.getElementById('symLockLayer'); const snapGridChk=document.getElementById('snapGrid'); const gridSize=document.getElementById('gridSize'); const gridSizeVal=document.getElementById('gridSizeVal'); const snapLineChk=document.getElementById('snapLine');
const symColor=document.getElementById('symColor'); const symLabelInput=document.getElementById('symLabel'); const symLabelSize=document.getElementById('symLabelSize'); const symLabelSizeVal=document.getElementById('symLabelSizeVal'); const symLabelColor=document.getElementById('symLabelColor');

// Nets tab
const addNetBtn = document.getElementById('addNet');
const delNetBtn = document.getElementById('delNet');
const exportNetsBtn = document.getElementById('exportNets');
const netsList = document.getElementById('netsList');

// ===== State =====
let imgW=0,imgH=0,origW=0,origH=0,imgBitmap=null,imgLoaded=false,rawImageData=null;
let viewScale=1,panX=0,panY=0,panning=false,panMode=false,textMode=false,eraserMode=false,lineMode=false,highlightMode=true,spaceHeld=false;
let lineStart=null,lineEnd=null,linePreview=null;
let layers=[],activeLayer=0,layerCounter=1;
let annotations=[],pendingEditor=null;
let symbols=[],selectedSym=-1,draggingSym=false;
let segments=[],selectedSeg=-1,draggingSeg=false;
let selectedAnn=-1,draggingAnn=false; let annOffset={dx:0,dy:0};
let lastWorld=null; let suppressNextClick=false;
let maskCanvas=null,maskCtx=null,maskImageData=null;
let history=[]; let lastErase=null;

// Manual arrows
let arrowsMode=false;

// nets + continuity
let netLabelMode=false; let contMode=false;
const netLabels=[];
let activeNet=-1;
let contSel1=null, contSel2=null, contResult=null;

// ===== Tabs init (scoped) =====
function initTabs(bar){
  const scope = bar.closest('.panel') || document;
  bar.addEventListener('click',(e)=>{
    const btn=e.target.closest('button[data-tab]'); if(!btn) return;
    const key=btn.dataset.tab;
    bar.querySelectorAll('button[data-tab]').forEach(b=> b.classList.toggle('active', b===btn));
    scope.querySelectorAll('.tabpane').forEach(p=> p.classList.toggle('active', p.id===`tab-${key}`));
  });
}

// ===== Utils =====
function logHistory(msg){ const t=new Date().toLocaleTimeString(); const line=`[${t}] ${msg}`; history.push(line); const div=document.createElement('div'); div.textContent=line; historyList.appendChild(div); historyList.scrollTop=historyList.scrollHeight; consoleOut.textContent+=line+'\\n'; consoleOut.scrollTop=consoleOut.scrollHeight; }
function getVar(name){ return parseInt(getComputedStyle(document.documentElement).getPropertyValue(name))||0; }
function setVar(name,px){ document.documentElement.style.setProperty(name, px+'px'); }
function saveDock(){ localStorage.setItem('dock_left',getVar('--left')); localStorage.setItem('dock_right',getVar('--right')); localStorage.setItem('dock_bottom',getVar('--bottom')); localStorage.setItem('dock_hide_left',dock.classList.contains('hide-left')?'1':'0'); localStorage.setItem('dock_hide_right',dock.classList.contains('hide-right')?'1':'0'); localStorage.setItem('dock_hide_bottom',dock.classList.contains('hide-bottom')?'1':'0'); }
function loadDock(){ const L=+(localStorage.getItem('dock_left')||'380'); const R=+(localStorage.getItem('dock_right')||'420'); const B=+(localStorage.getItem('dock_bottom')||'280'); setVar('--left',L); setVar('--right',R); setVar('--bottom',B); const hideL=localStorage.getItem('dock_hide_left')==='1'; const hideR=localStorage.getItem('dock_hide_right')==='1'; const hideB=localStorage.getItem('dock_hide_bottom')==='1'; dock.classList.toggle('hide-left',hideL); dock.classList.toggle('hide-right',hideR); dock.classList.toggle('hide-bottom',hideB); toggleLeftBtn.classList.toggle('active',!hideL); toggleRightBtn.classList.toggle('active',!hideR); toggleBottomBtn.classList.toggle('active',!hideB); }
function clamp(n,min,max){ return Math.max(min,Math.min(max,n)); }
function lerp(a,b,t){ return a+(b-a)*t; }

function initSplitters(){
  let dragging=null;
  function onMove(e){
    if(!dragging) return;
    const rect=dock.getBoundingClientRect();
    if(dragging==='left'){ const min=220,max=rect.width-getVar('--right')-280; setVar('--left', clamp(e.clientX-rect.left-12,min,max)); }
    else if(dragging==='right'){ const min=220,max=rect.width-getVar('--left')-280; setVar('--right', clamp(rect.right-e.clientX-12,min,max)); }
    else if(dragging==='bottom'){ const min=120,max=rect.height-220; setVar('--bottom', clamp(rect.bottom-e.clientY-12,min,max)); }
    setCanvasSizeToContainer();
  }
  function onUp(){ if(dragging){ dragging=null; saveDock(); } }
  splitLeft.addEventListener('mousedown', ()=>{ if(!dock.classList.contains('hide-left')) dragging='left'; });
  splitRight.addEventListener('mousedown', ()=>{ if(!dock.classList.contains('hide-right')) dragging='right'; });
  splitBottom.addEventListener('mousedown', ()=>{ if(!dock.classList.contains('hide-bottom')) dragging='bottom'; });
  window.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
}

toggleLeftBtn.addEventListener('click', ()=>{ dock.classList.toggle('hide-left'); toggleLeftBtn.classList.toggle('active'); saveDock(); setCanvasSizeToContainer(); });
toggleRightBtn.addEventListener('click', ()=>{ dock.classList.toggle('hide-right'); toggleRightBtn.classList.toggle('active'); saveDock(); setCanvasSizeToContainer(); });
toggleBottomBtn.addEventListener('click', ()=>{ dock.classList.toggle('hide-bottom'); toggleBottomBtn.classList.toggle('active'); saveDock(); setCanvasSizeToContainer(); });

function setCanvasSizeToContainer(){ const box=view.parentElement; const w=Math.max(300,Math.floor(box.clientWidth)); const h=Math.max(300,Math.floor(box.clientHeight)); [view,overlay,arrowsCanvas].forEach(c=>{c.width=w;c.height=h;}); drawBase(); redrawOverlay(); }
window.addEventListener('resize', setCanvasSizeToContainer);

function applyViewTransform(ctx){ ctx.translate(view.width*0.5+panX, view.height*0.5+panY); ctx.scale(viewScale,viewScale); }
function screenToImg(sx,sy){ const z=viewScale; return [(sx - view.width*0.5 - panX)/z + imgW*0.5, (sy - view.height*0.5 - panY)/z + imgH*0.5]; }
function imgToScreen(ix,iy){ return [(ix - imgW*0.5)*viewScale + view.width*0.5 + panX, (iy - imgH*0.5)*viewScale + view.height*0.5 + panY]; }
function fitToView(){ if(!imgLoaded) return; const fitScale=Math.min(view.width/imgW, view.height/imgH); viewScale=clamp(fitScale,.1,10); panX=0; panY=0; zoom.value=Math.round(viewScale*100); zoomVal.textContent=zoom.value+'%'; drawBase(); redrawOverlay(); }

function loadFromUrl(url, cb){
  const im=new Image();
  im.onload=()=>{ const src=document.createElement('canvas'); src.width=im.naturalWidth; src.height=im.naturalHeight; const sctx=src.getContext('2d',{willReadFrequently:true}); sctx.imageSmoothingEnabled=false; sctx.drawImage(im,0,0); ingestBitmap(src,im.naturalWidth,im.naturalHeight); if(cb) cb(); logHistory('Loaded image from URL'); };
  im.onerror=()=> alert('Could not load that image.');
  im.src=url;
}
fileInput.addEventListener('change',(e)=>{ const file=e.target.files[0]; if(!file) return; const url=URL.createObjectURL(file); loadFromUrl(url); logHistory('Loaded image from file: '+file.name); });
['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('drag'); }));
['dragleave','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('drag'); }));
drop.addEventListener('drop',(e)=>{ const file=e.dataTransfer.files[0]; if(file){ const url=URL.createObjectURL(file); loadFromUrl(url); logHistory('Loaded image via drag-drop: '+(file.name||'blob')); } });

function newLayer(name){ return { id: Date.now()+'-'+(layerCounter++), name, visible:true, opacity:(+alpha.value)/100, color:color.value, mask:new Uint8Array(imgW*imgH) }; }
function ingestBitmap(sourceCanvas, originalW=null, originalH=null){
  origW = originalW ?? sourceCanvas.width; origH = originalH ?? sourceCanvas.height;
  let dst = sourceCanvas; const maxD = Math.max(512, Math.min(8192, parseInt(maxDim.value||'4096',10)));
  if (autoDown.checked){ const scale = Math.min(1, maxD/Math.max(sourceCanvas.width, sourceCanvas.height)); if (scale<1){ const w=Math.max(1,Math.round(sourceCanvas.width*scale)); const h=Math.max(1,Math.round(sourceCanvas.height*scale)); const down=document.createElement('canvas'); down.width=w; down.height=h; const dctx=down.getContext('2d'); dctx.imageSmoothingEnabled=false; dctx.drawImage(sourceCanvas,0,0,sourceCanvas.width,sourceCanvas.height,0,0,w,h); dst=down; } }
  imgBitmap=dst; imgW=dst.width; imgH=dst.height; imgLoaded=true;
  const tctx=dst.getContext('2d',{willReadFrequently:true}); rawImageData=tctx.getImageData(0,0,imgW,imgH);
  maskCanvas=document.createElement('canvas'); maskCanvas.width=imgW; maskCanvas.height=imgH; maskCtx=maskCanvas.getContext('2d'); maskImageData=maskCtx.createImageData(imgW,imgH);
  layers=[ newLayer('Layer 1') ]; activeLayer=0; refreshLayerList();
  annotations=[]; symbols=[]; segments=[]; selectedSym=-1; selectedSeg=-1; selectedAnn=-1; netLabels.length=0; activeNet=-1; contSel1=contSel2=null;
  if (autoThresh.checked){ const t=computeAutoThreshold(rawImageData); thresh.value=t; threshVal.textContent=t; }
  const scaled=(origW!==imgW||origH!==imgH); meta.textContent=`Image: ${imgW}×${imgH}` + (scaled?` (from ${origW}×${origH})`:'') + ` • thresh=${thresh.value}`;
  fitToView(); refreshNetsList();
}

function drawBase(){ const ctx=vctx; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,view.width,view.height); if(!imgLoaded){ ctx.fillStyle='#0b0d12'; ctx.fillRect(0,0,view.width,view.height); ctx.fillStyle='#5b6a86'; ctx.font='14px system-ui, sans-serif'; ctx.fillText('Load a schematic image →', 16, 24); return; } ctx.save(); applyViewTransform(ctx); ctx.imageSmoothingEnabled=false; ctx.drawImage(imgBitmap, -imgW/2, -imgH/2); ctx.restore(); }

function drawAnnotationsToCtx(ctx, transformed){ if(!showAnnotationsChk.checked||!annotations.length) return; ctx.save(); ctx.textBaseline='middle'; ctx.textAlign='left'; for(const ann of annotations){ const size=Math.max(10,+ann.size||18); ctx.font = `${size}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif`; const x= transformed ? (ann.x - imgW/2) : ann.x; const y= transformed ? (ann.y - imgH/2) : ann.y; ctx.lineWidth=Math.max(2, Math.round(size/6)); ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.fillStyle=ann.color||'#ffff00'; ctx.strokeText(ann.text, x, y); ctx.fillText(ann.text, x, y); } ctx.restore(); }

function drawTinted(ctx,img,w,h,color){ tintCanvas.width=Math.max(1,Math.round(w)); tintCanvas.height=Math.max(1,Math.round(h)); tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height); tintCtx.drawImage(img,0,0,tintCanvas.width,tintCanvas.height); tintCtx.globalCompositeOperation='source-atop'; tintCtx.fillStyle=color||'#000'; tintCtx.fillRect(0,0,tintCanvas.width,tintCanvas.height); tintCtx.globalCompositeOperation='source-over'; ctx.drawImage(tintCanvas,-w/2,-h/2,w,h); }

function drawSymbols(ctx){
  for(let i=0;i<symbols.length;i++){
    const s=symbols[i]; const img=symbolImages[s.type]; if(!img) continue;
    ctx.save(); ctx.translate(s.x - imgW/2, s.y - imgH/2); ctx.rotate((s.rot||0) * Math.PI/180);
    const w=s.size, h=s.size*(img.height/Math.max(1,img.width));
    drawTinted(ctx,img,w,h,s.color||'#000'); ctx.rotate(-(s.rot||0)*Math.PI/180);
    if(s.label){ ctx.font=`${s.labelSize||16}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif`; ctx.textBaseline='middle'; ctx.fillStyle=s.labelColor||'#000'; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=3/viewScale; const dx=w/2+8+(s.labelDx||0), dy=(s.labelDy||0); ctx.strokeText(s.label,dx,dy); ctx.fillText(s.label,dx,dy); }
    ctx.restore();
  }
}

function drawSelectionOutline(ctx){
  if(selectedSym<0||selectedSym>=symbols.length) return;
  const s=symbols[selectedSym]; const img=symbolImages[s.type]; if(!img) return;
  ctx.save(); ctx.translate(s.x - imgW/2, s.y - imgH/2); ctx.rotate((s.rot||0)*Math.PI/180);
  const w=s.size,h=s.size*(img.height/Math.max(1,img.width));
  ctx.strokeStyle='#6bb2ff'; ctx.setLineDash([6,4]); ctx.lineWidth=2/viewScale; ctx.strokeRect(-w/2,-h/2,w,h); ctx.restore();
}

function redrawOverlay(){
  function drawSegments(ctx){ for(let i=0;i<segments.length;i++){ const s=segments[i]; const L=layers[s.layer]||layers[0]; if(!L||!L.visible) continue; ctx.save(); ctx.globalAlpha=Math.max(0,Math.min(1,L.opacity)); ctx.strokeStyle=L.color||'#f00'; ctx.lineWidth=Math.max(1,s.thick||(+thickness.value|0))/viewScale; ctx.setLineDash([]); ctx.beginPath(); ctx.moveTo(s.x1 - imgW/2, s.y1 - imgH/2); ctx.lineTo(s.x2 - imgW/2, s.y2 - imgH/2); ctx.stroke(); ctx.restore(); } }
  const ctx=octx; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,overlay.width,overlay.height); if(!imgLoaded) return; ctx.save(); applyViewTransform(ctx); ctx.imageSmoothingEnabled=false;
  for(const L of layers){ if(!L.visible) continue; const a=Math.round(clamp(L.opacity,0,1)*255); let R=255,G=0,B=0; try{ R=parseInt(L.color.slice(1,3),16); G=parseInt(L.color.slice(3,5),16); B=parseInt(L.color.slice(5,7),16);}catch(_){}
    const data=maskImageData.data, mask=L.mask; for(let i=0,j=0;i<mask.length;i++,j+=4){ if(mask[i]){ data[j]=R; data[j+1]=G; data[j+2]=B; data[j+3]=a; } else { data[j]=data[j+1]=data[j+2]=data[j+3]=0; } } 
    maskCtx.putImageData(maskImageData,0,0); ctx.drawImage(maskCanvas,-imgW/2,-imgH/2);
  }
  drawSegments(ctx);
  drawSymbols(ctx);
  drawSelectionOutline(ctx);
  if(linePreview){ ctx.save(); ctx.strokeStyle='#6bb2ff'; ctx.setLineDash([8,6]); ctx.lineWidth=Math.max(1,(thickness.value|0))/viewScale; ctx.beginPath(); ctx.moveTo(linePreview.x1 - imgW/2, linePreview.y1 - imgH/2); ctx.lineTo(linePreview.x2 - imgW/2, linePreview.y2 - imgH/2); ctx.stroke(); ctx.restore(); }
  drawAnnotationsToCtx(ctx,true);
  drawNetLabels(ctx,true);
  ctx.restore();
  drawContinuityUI(octx);
}

function snapPosition(ix,iy){
  let x=ix,y=iy;
  if(snapGridChk.checked){ const gs=+gridSize.value; x=Math.round(x/gs)*gs; y=Math.round(y/gs)*gs; }
  if(snapLineChk.checked){ const hit=findNearestInk(x|0,y|0,+snap.value,+thresh.value); if(hit){ x=hit.x; y=hit.y; } }
  return [x,y];
}

view.addEventListener('wheel',(e)=>{
  if(!imgLoaded) return; e.preventDefault(); hideEditor();
  const rect=view.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
  const prev=viewScale, factor=(e.deltaY<0)?1.1:0.9, next=clamp(prev*factor, .1, 10);
  const pivotX=sx - view.width*0.5, pivotY=sy - view.height*0.5, k=next/prev;
  panX=(panX - pivotX)*k + pivotX; panY=(panY - pivotY)*k + pivotY; viewScale=next;
  zoom.value=Math.round(viewScale*100); zoomVal.textContent=zoom.value+'%'; drawBase(); redrawOverlay();
},{passive:false});

window.addEventListener('keydown',(e)=>{
  if(e.code==='Space') spaceHeld=true;
  const tgt = e.target;
  const typing = tgt && (tgt.tagName==='INPUT' || tgt.tagName==='TEXTAREA' || tgt.isContentEditable);
  if(!typing && (e.key==='a' || e.key==='A')){ e.preventDefault(); autoLineColor(); }
  if(e.key==='p'||e.key==='P'){ panMode=!panMode; panToggle.classList.toggle('active',panMode); eraserMode=false; eraserToggle.classList.remove('active'); }
  if(e.key==='t'||e.key==='T'){ toggleTextMode(); }
  if(e.key==='e'||e.key==='E'){ toggleEraser(); }
  if(e.key==='l'||e.key==='L'){ toggleLine(); }
  if(e.key==='n'||e.key==='N'){ toggleNetLabelMode(); }
  if(e.key==='c'||e.key==='C'){ toggleContMode(); }
  if(e.key==='Delete' && selectedSym>=0){ symbols.splice(selectedSym,1); selectedSym=-1; redrawOverlay(); }
  if(selectedSym>=0){
    const s=symbols[selectedSym];
    if(e.key==='['){ s.rot=(s.rot-(45))%360; redrawOverlay(); }
    if(e.key===']'){ s.rot=(s.rot+(45))%360; redrawOverlay(); }
    if(e.key==='+'){ s.size=clamp(s.size+4,20,200); symSize.value=s.size; symSizeVal.textContent=s.size; redrawOverlay(); }
    if(e.key==='-'){ s.size=clamp(s.size-4,20,200); symSize.value=s.size; symSizeVal.textContent=s.size; redrawOverlay(); }
  }
  if(e.key==='Escape'){ hideEditor(true); cancelLine(); }
});
window.addEventListener('keyup',(e)=>{ if(e.code==='Space') spaceHeld=false; });

let lastMouse=null, mouseDown=false;
view.addEventListener('contextmenu', e=> e.preventDefault());
view.addEventListener('auxclick', e=>{ if(e.button===1) e.preventDefault(); });

view.addEventListener('mousedown',(e)=>{
  if(!imgLoaded) return;
  mouseDown=true;
  if(e.button===1) e.preventDefault();
  if(spaceHeld||panMode||e.button===1){ hideEditor(); panning=true; lastMouse={x:e.clientX,y:e.clientY}; return; }
  const [ix,iy]=screenToImg(e.offsetX,e.offsetY);
  if(eraserMode){ eraseAt(ix,iy,+eraserSize.value); redrawOverlay(); return; }
  if(lineMode){ const [sx,sy]=snapPosition(ix,iy); lineStart={x:sx,y:sy}; lineEnd={x:sx,y:sy}; linePreview={x1:sx,y1:sy,x2:sx,y2:sy}; redrawOverlay(); return; }
  let hit = hitTestSymbol(ix,iy);
  if(hit>=0){ selectedSym=hit; selectedSeg=-1; selectedAnn=-1; draggingSym=true; suppressNextClick=true; syncSymbolUI(); redrawOverlay(); return; }
  hit = hitTestAnnotation(ix,iy);
  if(hit>=0){ selectedAnn=hit; selectedSym=-1; selectedSeg=-1; draggingAnn=true; annOffset.dx=ix-annotations[hit].x; annOffset.dy=iy-annotations[hit].y; suppressNextClick=true; redrawOverlay(); return; }
  hit = hitTestSegment(ix,iy);
  if(hit>=0){ selectedSeg=hit; selectedSym=-1; selectedAnn=-1; draggingSeg=true; lastWorld={x:ix,y:iy}; suppressNextClick=true; redrawOverlay(); return; }
});
window.addEventListener('mousemove',(e)=>{
  if(panning){ const dx=e.clientX-lastMouse.x, dy=e.clientY-lastMouse.y; lastMouse={x:e.clientX,y:e.clientY}; panX+=dx; panY+=dy; drawBase(); redrawOverlay(); }
  if(!imgLoaded||!mouseDown) return;
  const rect=view.getBoundingClientRect(); const [ix,iy]=screenToImg(e.clientX-rect.left, e.clientY-rect.top);
  if(eraserMode){ eraseLineTo(ix,iy,+eraserSize.value); redrawOverlay(); }
  else if(lineMode&&lineStart){ const [sx,sy]=snapPosition(ix,iy); lineEnd={x:sx,y:sy}; linePreview={x1:lineStart.x,y1:lineStart.y,x2:sx,y2:sy}; redrawOverlay(); }
  else if(draggingSym&&selectedSym>=0){ const s=symbols[selectedSym]; const [sx,sy]=snapPosition(ix,iy); s.x=sx; s.y=sy; if(symLockLayer.checked) s.layer=activeLayer; redrawOverlay(); }
  else if(draggingAnn&&selectedAnn>=0){ const a=annotations[selectedAnn]; let nx=ix-annOffset.dx, ny=iy-annOffset.dy; [nx,ny]=snapPosition(nx,ny); a.x=nx; a.y=ny; redrawOverlay(); }
});
window.addEventListener('mouseup',()=>{
  panning=false; mouseDown=false; lastErase=null; draggingSym=false; draggingSeg=false; draggingAnn=false;
  if(lineMode && lineStart && lineEnd){
    if(segmentMode.checked){ const mask=layers[activeLayer].mask; drawSmartNetLine(mask, lineStart.x|0, lineStart.y|0, lineEnd.x|0, lineEnd.y|0); }
    else { segments.push({x1:lineStart.x|0,y1:lineStart.y|0,x2:lineEnd.x|0,y2:lineEnd.y|0,thick:+thickness.value,layer:activeLayer}); selectedSeg=segments.length-1; }
    lineStart=null; lineEnd=null; linePreview=null; redrawOverlay(); logHistory('Line placed on '+layers[activeLayer].name+(segmentMode.checked?' (stop at junctions)':' (movable)'));
  }
});

view.addEventListener('click',(e)=>{
  if(suppressNextClick){ suppressNextClick=false; return; }
  if(e.ctrlKey){
    const [cx,cy]=screenToImg(e.offsetX,e.offsetY);
    if(hitTestSymbol(cx,cy)<0 && hitTestAnnotation(cx,cy)<0 && hitTestSegment(cx,cy)<0){ selectedSym=-1; selectedAnn=-1; selectedSeg=-1; redrawOverlay(); return; }
  }
  if(!imgLoaded) return; if(spaceHeld||panMode) return;
  const [ix,iy]=screenToImg(e.offsetX,e.offsetY);
  if(textMode){ openEditor(e.offsetX,e.offsetY); return; }
  if(eraserMode) return;
  if(selectedAnn>=0){ const hitSel=(hitTestAnnotation(ix,iy)===selectedAnn); if(hitSel){ return; } }
  if(!highlightMode) return;
  if(segmentMode.checked) traceSegment(ix,iy,{clear:e.shiftKey}); else traceFlood(ix,iy,{clear:e.shiftKey});
});

view.addEventListener('dragover',(e)=>{ e.preventDefault(); e.dataTransfer.dropEffect='copy'; });
view.addEventListener('drop',(e)=>{
  e.preventDefault();
  const key=e.dataTransfer.getData('text/plain'); if(!key) return;
  const rect=view.getBoundingClientRect(); let [ix,iy]=screenToImg(e.clientX-rect.left, e.clientY-rect.top); [ix,iy]=snapPosition(ix,iy);
  if(key==='text'){ const ann={x:ix,y:iy,text:'Text',size:+labelSize.value,color:labelColor.value}; annotations.push(ann); selectedAnn=annotations.length-1; selectedSym=-1; selectedSeg=-1; openEditor(e.clientX-rect.left,e.clientY-rect.top,selectedAnn); logHistory('Dropped text annotation'); redrawOverlay(); return; }
  const s={type:key,x:ix,y:iy,size:+symSize.value,rot:0,layer:activeLayer,color:symColor.value,label:symLabelInput.value.trim(),labelSize:+symLabelSize.value,labelColor:symLabelColor.value,labelDx:0,labelDy:0};
  symbols.push(s); selectedSym=symbols.length-1; syncSymbolUI(); logHistory('Dropped symbol: '+key); redrawOverlay();
});

function toggleTextMode(){ textMode=!textMode; textModeBtn.classList.toggle('active',textMode); if(textMode){ panMode=false; eraserMode=false; eraserToggle.classList.remove('active'); lineMode=false; lineToggle?.classList?.remove('active'); highlightMode=false; highlightToggle?.classList?.remove('active'); } }
function toggleEraser(){ eraserMode=!eraserMode; eraserToggle.classList.toggle('active',eraserMode); if(eraserMode){ textMode=false; textModeBtn.classList.remove('active'); lineMode=false; lineToggle?.classList?.remove('active'); panMode=false; highlightMode=false; highlightToggle?.classList?.remove('active'); } }
function toggleLine(){ lineMode=!lineMode; lineToggle.classList.toggle('active', lineMode); if(lineMode){ eraserMode=false; eraserToggle.classList.remove('active'); textMode=false; textModeBtn.classList.remove('active'); panMode=false; highlightMode=false; highlightToggle?.classList?.remove('active'); } else { cancelLine(); } }
function cancelLine(){ lineStart=null; lineEnd=null; linePreview=null; redrawOverlay(); }



// Hidden trace + mask centerline to derive a clean path for arrows
function __buildPathViaTempTrace(ix, iy){
  if(!imgLoaded || typeof traceSegment!=='function') return null;
  const prevActive = activeLayer;
  const temp = { id: 'temp-trace-'+Date.now(), name: 'TempTrace', visible:false, opacity:1, color:'#ff0000', mask:new Uint8Array(imgW*imgH) };
  layers.push(temp);
  activeLayer = layers.length-1;
  const _log = typeof logHistory==='function' ? logHistory : null;
  if(_log){ window.logHistory = function(){ /*silenced*/ }; }
  try{
    traceSegment(ix, iy, {clear:true}); // writes into temp mask
    const mask = layers[activeLayer].mask;
    const pts = [];
    const step = 10;
    for(let y=0; y<imgH; y++){
      let run=0, startX=-1, bestLen=0, bestMid=-1;
      for(let x=0; x<imgW; x++){
        const v = mask[y*imgW + x];
        if(v){ if(run===0) startX=x; run++; }
        else if(run){
          if(run>bestLen){ bestLen=run; bestMid = (startX + x-1)>>1; }
          run=0; startX=-1;
        }
      }
      if(run && run>bestLen){ bestLen=run; bestMid = (startX + imgW-1)>>1; }
      if(bestLen>6 && bestMid>=0){ pts.push({x:bestMid, y}); }
    }
    if(pts.length<2) return null;
    const th=[pts[0]];
    for(let i=1;i<pts.length;i++){
      const a=th[th.length-1], b=pts[i];
      if(Math.hypot(b.x-a.x, b.y-a.y) >= step) th.push(b);
    }
    return th.length>=2 ? th : null;
  }catch(err){ console.error(err); return null; }
  finally{
    layers.pop();
    activeLayer = prevActive;
    if(_log){ window.logHistory = _log; }
    if(typeof redrawOverlay==='function') redrawOverlay();
  }
}

// Quick check: is there highlight (red) under this screen pixel?
function __overlayHasRedAt(sx, sy){
  const ov = document.getElementById('overlay'); if(!ov) return false;
  const ctx = ov.getContext('2d'); if(!ctx) return false;
  const x = Math.max(0, Math.min(ov.width-3, Math.round(sx-1)));
  const y = Math.max(0, Math.min(ov.height-3, Math.round(sy-1)));
  const a = ctx.getImageData(x,y,3,3).data;
  for(let i=0;i<a.length;i+=4){
    const r=a[i], g=a[i+1], b=a[i+2], al=a[i+3];
    if(al>10 && r>150 && r>g+20) return true;
  }
  return false;
}
// === Highlight tool (H) ===
function toggleHighlight(){
  highlightMode = !highlightMode;
  if (highlightMode){
    // turn off other modes
    textMode = false; textModeBtn.classList.remove('active');
    eraserMode = false; eraserToggle.classList.remove('active');
    lineMode = false; lineToggle?.classList?.remove('active');
    panMode = false; panToggle.classList.remove('active');
    // also turn off net/continuity if they are on
    if (typeof netLabelMode!=='undefined' && netLabelMode){ netLabelMode = false; netLabelBtn?.classList?.remove('active'); }
    if (typeof contMode!=='undefined' && contMode){ contMode = false; contToggleBtn?.classList?.remove('active'); }
  }
  highlightToggle?.classList?.toggle('active', highlightMode);
}
highlightToggle?.addEventListener('click', toggleHighlight);

// Keyboard shortcut H to activate highlight mode
window.addEventListener('keydown', (e)=>{
  const tgt = e.target;
  const typing = tgt && (tgt.tagName==='INPUT' || tgt.tagName==='TEXTAREA' || tgt.isContentEditable);
  if (!typing && (e.key==='h' || e.key==='H')){
    e.preventDefault();
    highlightMode = true;
    highlightToggle?.classList?.add('active');
    // disable others
    textMode=false; textModeBtn.classList.remove('active');
    eraserMode=false; eraserToggle.classList.remove('active');
    lineMode=false; lineToggle?.classList?.remove('active');
    panMode=false; panToggle.classList.remove('active');
  }
});
// === /Highlight tool ===
// ==== UPDATED: annotation editor now supports editing existing labels (fixes duplication on drop) ====
function openEditor(sx, sy, editIndex = -1){
  pendingEditor = { sx, sy, editIndex };
  let px = sx, py = sy;

  if (editIndex >= 0) {
    const a = annotations[editIndex];
    const [ex, ey] = imgToScreen(a.x, a.y);
    px = ex; py = ey;
    labelEditor.value = a.text || '';
  } else {
    labelEditor.value = '';
  }

  labelEditor.style.left = px + 'px';
  labelEditor.style.top  = py + 'px';
  labelEditor.style.fontSize = labelSize.value + 'px';
  labelEditor.style.display = 'block';
  labelEditor.focus();
  labelEditor.select();
}
function hideEditor(cancel=false){ if(!labelEditor||labelEditor.style.display==='none') return; if(!cancel&&pendingEditor) commitEditor(); labelEditor.style.display='none'; pendingEditor=null; }
function commitEditor(){
  if (!pendingEditor) return;
  const text = (labelEditor.value || '').trim();
  const { sx, sy, editIndex } = pendingEditor;
  if (!text) return;

  if (editIndex >= 0) {
    const a = annotations[editIndex];
    a.text  = text;
    a.size  = +labelSize.value;
    a.color = labelColor.value;
    selectedAnn = editIndex;
    logHistory(`Edited label → "${text}"`);
  } else {
    const [ix, iy] = screenToImg(sx, sy);
    annotations.push({ x:ix, y:iy, text, size:+labelSize.value, color:labelColor.value });
    selectedAnn = annotations.length - 1;
    logHistory(`Added label "${text}" at (${Math.round(ix)}, ${Math.round(iy)})`);
  }
  redrawOverlay();
}
labelEditor.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); commitEditor(); hideEditor(true);} if(e.key==='Escape'){ e.preventDefault(); hideEditor(true);} });
labelEditor.addEventListener('blur',()=>{ commitEditor(); hideEditor(true); });
// ==== /UPDATED ====

function buildPalette(){ palette.innerHTML=''; for(const [key,img] of Object.entries(symbolImages)){ const cell=document.createElement('div'); cell.className='sym'; const im=document.createElement('img'); im.src=img.src; im.draggable=true; im.title=key; im.addEventListener('dragstart',(e)=>{ e.dataTransfer.setData('text/plain',key); cell.classList.add('dragging'); }); im.addEventListener('dragend',()=> cell.classList.remove('dragging')); cell.appendChild(im); const lab=document.createElement('div'); lab.className='symLabel'; lab.textContent=key; const wrap=document.createElement('div'); wrap.appendChild(cell); wrap.appendChild(lab); palette.appendChild(wrap); } }
buildPalette();

function hitTestSymbol(ix,iy){
  for(let i=symbols.length-1;i>=0;i--){
    const s=symbols[i]; const img=symbolImages[s.type]; if(!img) continue;
    const angle=-(s.rot||0)*Math.PI/180; const dx=ix-s.x, dy=iy-s.y;
    const lx=dx*Math.cos(angle)-dy*Math.sin(angle), ly=dx*Math.sin(angle)+dy*Math.cos(angle);
    const w=s.size, h=s.size*(img.height/Math.max(1,img.width));
    if(lx>=-w/2 && lx<=w/2 && ly>=-h/2 && ly<=h/2) return i;
  }
  return -1;
}

function syncSymbolUI(){
  if(selectedSym<0||selectedSym>=symbols.length) return;
  const s=symbols[selectedSym];
  symSize.value=s.size; symSizeVal.textContent=s.size;
  symColor.value=s.color||'#000000';
  symLabelInput.value=s.label||'';
  symLabelSize.value=s.labelSize||16; symLabelSizeVal.textContent=symLabelSize.value;
  symLabelColor.value=s.labelColor||'#000000';
}

symSize.addEventListener('input',()=>{ symSizeVal.textContent=symSize.value; if(selectedSym>=0){ symbols[selectedSym].size=+symSize.value; redrawOverlay(); }});
rotL.addEventListener('click',()=>{ if(selectedSym<0) return; symbols[selectedSym].rot=(symbols[selectedSym].rot-45)%360; redrawOverlay(); });
rotR.addEventListener('click',()=>{ if(selectedSym<0) return; symbols[selectedSym].rot=(symbols[selectedSym].rot+45)%360; redrawOverlay(); });
delSym.addEventListener('click',()=>{ if(selectedSym<0) return; symbols.splice(selectedSym,1); selectedSym=-1; redrawOverlay(); });

symColor.addEventListener('input',()=>{ if(selectedSym>=0){ symbols[selectedSym].color=symColor.value; redrawOverlay(); }});
symLabelInput.addEventListener('input',()=>{ if(selectedSym>=0){ symbols[selectedSym].label=symLabelInput.value; redrawOverlay(); }});
symLabelSize.addEventListener('input',()=>{ symLabelSizeVal.textContent=symLabelSize.value; if(selectedSym>=0){ symbols[selectedSym].labelSize=+symLabelSize.value; redrawOverlay(); }});
symLabelColor.addEventListener('input',()=>{ if(selectedSym>=0){ symbols[selectedSym].labelColor=symLabelColor.value; redrawOverlay(); }});

gridSize.addEventListener('input',()=>{ gridSizeVal.textContent=gridSize.value; });
eraserSize.addEventListener('input',()=> eraserSizeVal.textContent=eraserSize.value );
thresh.addEventListener('input',()=> threshVal.textContent=thresh.value );
snap.addEventListener('input',()=> snapVal.textContent=snap.value );
alpha.addEventListener('input',()=> alphaVal.textContent=(alpha.value/100).toFixed(2) );
thickness.addEventListener('input',()=> thicknessVal.textContent=thickness.value );
limit.addEventListener('input',()=> limitVal.textContent=limit.value );
maxDim.addEventListener('input',()=> maxDimVal.textContent=maxDim.value );
zoom.addEventListener('input',()=>{
  const z = clamp(parseInt(zoom.value||'100',10)/100, .1, 10);
  viewScale = z;
  zoomVal.textContent = Math.round(viewScale*100)+'%';
  drawBase(); redrawOverlay();
});

document.getElementById('clear').addEventListener('click',()=>{ for(const L of layers) L.mask.fill(0); annotations=[]; symbols=[]; segments=[]; selectedSym=-1; selectedSeg=-1; selectedAnn=-1; netLabels.length=0; activeNet=-1; contSel1=contSel2=null; refreshNetsList(); redrawOverlay(); logHistory('Cleared all layers, annotations, symbols, segments, and net labels'); });
fitBtn.addEventListener('click',()=> fitToView());
loadSample.addEventListener('click',()=> loadFromUrl(SAMPLE_URL));
analyzeBtn.addEventListener('click',()=>{ if(!rawImageData) return; const t=computeAutoThreshold(rawImageData); thresh.value=t; threshVal.textContent=t; logHistory('Auto threshold computed: '+t); });
panToggle.addEventListener('click',()=>{ panMode=!panMode; panToggle.classList.toggle('active',panMode); if(panMode){ eraserMode=false; eraserToggle.classList.remove('active'); lineMode=false; lineToggle.classList.remove('active'); textMode=false; textModeBtn.classList.remove('active'); highlightMode=false; highlightToggle?.classList?.remove('active'); } });
lineToggle.addEventListener('click',()=> toggleLine());
if (netLabelBtn) netLabelBtn.addEventListener('click', ()=>{ highlightMode=false; highlightToggle?.classList?.remove('active'); });
if (contToggleBtn) contToggleBtn.addEventListener('click', ()=>{ highlightMode=false; highlightToggle?.classList?.remove('active'); });

function getHighlightR(){ return Math.max(1,Math.round(+thickness.value/2)); }

// ===== Auto line color =====
const AUTO_COLORS = ['#ff4d4d','#ffa500','#ffd93b','#4dff4d','#4dffff','#4d7fff','#b84dff','#ff4dd2','#00d2ff','#00ff88','#ff7f50','#a3ff00'];
let autoColorIndex = parseInt(localStorage.getItem('autoColorIndex')||'0',10) || 0;
function pickAutoColor(){
  const used = new Set(layers.map(L => (L.color||'').toLowerCase()));
  for(let i=0;i<AUTO_COLORS.length;i++){
    const idx = (autoColorIndex + i) % AUTO_COLORS.length;
    const c = AUTO_COLORS[idx];
    if(!used.has(c.toLowerCase())){
      autoColorIndex = (idx + 1) % AUTO_COLORS.length;
      localStorage.setItem('autoColorIndex', String(autoColorIndex));
      return c;
    }
  }
  autoColorIndex = (autoColorIndex + 1) % AUTO_COLORS.length;
  localStorage.setItem('autoColorIndex', String(autoColorIndex));
  return AUTO_COLORS[autoColorIndex];
}
function autoLineColor(){
  const c = pickAutoColor();
  color.value = c;
  if(layers.length){ layers[activeLayer].color = c; refreshLayerList(); }
  redrawOverlay();
  logHistory('Auto color → '+c);
}
autoColorBtn?.addEventListener('click', autoLineColor);
// ===== /Auto line color =====

function traceFlood(ix,iy,{clear=false}={}){
  if(!layers.length) return; const overlayMask=layers[activeLayer].mask;
  if(ix<0||iy<0||ix>=imgW||iy>=imgH) return; if(clear) overlayMask.fill(0);
  const threshold=+thresh.value; const start=findNearestInk(ix|0,iy|0,+snap.value,threshold);
  if(!start){ alert('No line pixels near click. Increase Snap radius or adjust Threshold.'); return; }
  const q=[],seen=new Uint8Array(imgW*imgH), MAX=(+limit.value)*1000; let count=0; const idx=start.y*imgW+start.x; q.push(idx); seen[idx]=1; const r=getHighlightR();
  while(q.length){ const cur=q.shift(); count++; if(count>MAX){ console.warn('Early stop',MAX); break; } stampMaskIdx(overlayMask,cur,r); const cx=cur%imgW, cy=(cur/imgW)|0;
    for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue; const nIdx=ny*imgW+nx; if(seen[nIdx]) continue; if(isInk(nx,ny,threshold)){ seen[nIdx]=1; q.push(nIdx);} } } }
  redrawOverlay(); logHistory(`Flood highlight at (${Math.round(ix)}, ${Math.round(iy)}) on ${layers[activeLayer].name}`);
}

function traceSegment(ix,iy,{clear=false}={}){
  if(!layers.length) return; const overlayMask=layers[activeLayer].mask;
  if(ix<0||iy<0||ix>=imgW||iy>=imgH) return; if(clear) overlayMask.fill(0);
  const threshold = +thresh.value; const r0 = +snap.value; const start = findNearestInkRobust(ix|0, iy|0, r0, threshold);;
  if(!start){ if(typeof logHistory==='function') logHistory('No line pixels near click. Try Snap 12–18 and Threshold ~210–235.'); return; }
  stampMask(overlayMask,start.x,start.y,getHighlightR());
  const neigh=neighbors(start.x,start.y,threshold); if(neigh.length===0){ redrawOverlay(); return; }
  for(const n of neigh.slice(0,2)) walkFrom(overlayMask,start.x,start.y,n.x,n.y,threshold);
  redrawOverlay(); logHistory(`Segment highlight at (${Math.round(ix)}, ${Math.round(iy)}) on ${layers[activeLayer].name}`);
}

function walkFrom(mask,px,py,cx,cy,threshold){ let steps=0; const MAX_STEPS=(+limit.value)*1000; const r=getHighlightR();
  while(steps++<MAX_STEPS){ stampMask(mask,cx,cy,r); const next=chooseNextStep(px,py,cx,cy,threshold); if(!next) break; px=cx; py=cy; cx=next.x; cy=next.y; } }

function chooseNextStep(px,py,cx,cy,threshold){
  const ring=Array.from({length:3},()=>[0,0,0]); const cands=[];
  for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue; if(nx===px&&ny===py) continue; if(isInk(nx,ny,threshold)){ ring[dy+1][dx+1]=1; cands.push({x:nx,y:ny,dx,dy}); } } }
  let comps=0; const seen=Array.from({length:3},()=>[0,0,0]); const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  function flood(i,j){ const q=[[i,j]]; seen[i][j]=1; while(q.length){ const [a,b]=q.shift(); for(const [di,dj] of dirs){ const ni=a+di, nj=b+dj; if(ni<0||nj<0||ni>2||nj>2) continue; if(!seen[ni][nj]&&ring[ni][nj]){ seen[ni][nj]=1; q.push([ni,nj]); } } } }
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){ if(ring[i][j]&&!seen[i][j]){ comps++; flood(i,j); } }
  if(cands.length===0) return null; if(comps!==1) return null;
  const dirx=cx-px, diry=cy-py, dirLen=Math.hypot(dirx,diry)||1; let best=null, bestScore=-Infinity;
  for(const c of cands){ const clen=Math.hypot(c.dx,c.dy)||1; const cos=(dirx*c.dx + diry*c.dy)/(dirLen*clen); const lateral=Math.abs(dirx*c.dy - diry*c.dx)/(dirLen*clen); const score=cos - 0.05*lateral; if(score>bestScore){ bestScore=score; best=c; } }
  return best?{x:best.x,y:best.y}:null;
}

function neighbors(x,y,threshold,ex=null,ey=null){ const out=[]; for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue; if(ex!==null && nx===ex && ny===ey) continue; if(isInk(nx,ny,threshold)) out.push({x:nx,y:ny}); } } return out; }

function stampMask(mask,x,y,r=1){ const r2=r*r; const minY=Math.max(0,y-r), maxY=Math.min(imgH-1,y+r); const minX=Math.max(0,x-r), maxX=Math.min(imgW-1,x+r);
  for(let yy=minY;yy<=maxY;yy++){ for(let xx=minX;xx<=maxX;xx++){ const dx=xx-x, dy=yy-y; if(dx*dx+dy*dy>r2) continue; mask[yy*imgW + xx]=1; } } }
function clearMask(mask,x,y,r=6){ const r2=r*r; const minY=Math.max(0,y-r), maxY=Math.min(imgH-1,y+r); const minX=Math.max(0,x-r), maxX=Math.min(imgW-1,x+r);
  for(let yy=minY;yy<=maxY;yy++){ for(let xx=minX;xx<=maxX;xx++){ const dx=xx-x, dy=yy-y; if(dx*dx+dy*dy>r2) continue; mask[yy*imgW + xx]=0; } } }
function stampMaskIdx(mask,idx,r=1){ stampMask(mask, idx%imgW, (idx/imgW)|0, r); }
function drawLineOnMask(mask,x0,y0,x1,y1,r){ const dx=x1-x0, dy=y1-y0; const steps=Math.max(1,Math.ceil(Math.hypot(dx,dy))); for(let i=0;i<=steps;i++){ const t=i/steps; const x=Math.round(x0+dx*t); const y=Math.round(y0+dy*t); stampMask(mask,x,y,r); } }
function walkDirectional(mask,px,py,cx,cy,threshold,dirx,diry){
  let steps=0; const MAX_STEPS=(+limit.value)*1000; const r=getHighlightR();
  const dlen=Math.hypot(dirx,diry)||1; dirx/=dlen; diry/=dlen;
  while(steps++<MAX_STEPS){
    stampMask(mask,cx,cy,r);
    const next=chooseNextStep(px,py,cx,cy,threshold);
    if(!next) break;
    const vx=next.x-cx, vy=next.y-cy;
    const vlen=Math.hypot(vx,vy)||1;
    const dot=(vx/vlen)*dirx + (vy/vlen)*diry;
    if(dot<-0.2) break;
    px=cx; py=cy; cx=next.x; cy=next.y;
  }
}
function drawSmartNetLine(mask,sx,sy,ex,ey){
  const threshold=+thresh.value;
  const s=findNearestInk(sx|0,sy|0,+snap.value,threshold);
  if(!s){ drawLineOnMask(mask,sx|0,sy|0,ex|0,ey|0,getHighlightR()); return; }
  stampMask(mask,s.x,s.y,getHighlightR());
  const neigh=neighbors(s.x,s.y,threshold);
  if(neigh.length===0){ drawLineOnMask(mask,sx|0,sy|0,ex|0,ey|0,getHighlightR()); return; }
  const dirx=ex-sx, diry=ey-sy; const dlen=Math.hypot(dirx,diry)||1;
  let best=null,bestScore=-1;
  for(const n of neigh){ const vx=n.x-s.x, vy=n.y-s.y; const vlen=Math.hypot(vx,vy)||1; const dot=(vx/vlen)*(dirx/dlen) + (vy/vlen)*(diry/dlen); if(dot>bestScore){ bestScore=dot; best=n; } }
  if(!best){ drawLineOnMask(mask,sx|0,sy|0,ex|0,ey|0,getHighlightR()); return; }
  walkDirectional(mask,s.x,s.y,best.x,best.y,threshold,dirx,diry);
}

function isInk(x,y,threshold){ const i=(y*imgW + x)*4; const r=rawImageData.data[i], g=rawImageData.data[i+1], b=rawImageData.data[i+2], a=rawImageData.data[i+3]; if(a<10) return false; const Y=0.2126*r + 0.7152*g + 0.0722*b; return Y < threshold; }
function findNearestInk(cx,cy,radius,threshold){ if(isInk(cx,cy,threshold)) return {x:cx,y:cy}; for(let r=1;r<=radius;r++){ for(let dy=-r;dy<=r;dy++){ const y=cy+dy; if(y<0||y>=imgH) continue; for(let dx=-r;dx<=r;dx++){ const x=cx+dx; if(x<0||x>=imgW) continue; if(dx*dx+dy*dy>r*r) continue; if(isInk(x,y,threshold)) return {x,y}; } } } return null; }
// More forgiving nearest-ink search (expands radius, relaxes threshold)
function findNearestInkRobust(cx,cy,radius,threshold){
  let hit = findNearestInk(cx,cy,Math.max(1, radius|0), threshold);
  if(hit) return hit;
  const radii = [Math.round(radius*1.5)+2, Math.round(radius*2)+3, Math.round(radius*3)+5, 24, 32, 40];
  for(const r of radii){
    hit = findNearestInk(cx,cy,r,threshold);
    if(hit) return hit;
  }
  const ths = [threshold+10, threshold+20, threshold+30];
  for(const t of ths){
    const tt = Math.min(250, Math.max(0, t|0));
    hit = findNearestInk(cx,cy,Math.max(10, radius*2|0), tt);
    if(hit) return hit;
  }
  return null;
}


function computeAutoThreshold(imgData){ const bins=new Uint32Array(256); const d=imgData.data; const N=imgData.width*imgData.height; const step=Math.max(1,Math.floor(N/600000));
  for(let p=0,idx=0;p<N;p+=step,idx=p*4){ const r=d[idx],g=d[idx+1],b=d[idx+2],a=d[idx+3]; if(a<10) continue; const Y=Math.min(255,Math.max(0,Math.round(0.2126*r + 0.7152*g + 0.0722*b))); bins[Y]++; }
  let sum=0,total=0; for(let t=0;t<256;t++){ sum+=t*bins[t]; total+=bins[t]; }
  let sumB=0,wB=0,maxVar=-1,thr=120;
  for(let t=0;t<256;t++){ wB+=bins[t]; if(wB===0) continue; const wF=total-wB; if(wF===0) break; sumB+=t*bins[t]; const mB=sumB/wB; const mF=(sum-sumB)/wF; const between=wB*wF*(mB-mF)*(mB-mF); if(between>maxVar){ maxVar=between; thr=t; } }
  return Math.min(220, Math.max(20, Math.round(thr)));
}

function refreshLayerList(){ layerList.innerHTML=''; layers.forEach((L,idx)=>{
  const row=document.createElement('div'); row.className='layerItem'+(idx===activeLayer?' active':''); row.addEventListener('click',()=>{ activeLayer=idx; refreshLayerList(); redrawOverlay(); });
  const eye=document.createElement('div'); eye.className='eye '+(L.visible?'on':'off'); eye.title=L.visible?'Visible':'Hidden'; eye.addEventListener('click',(e)=>{ e.stopPropagation(); L.visible=!L.visible; eye.className='eye '+(L.visible?'on':'off'); redrawOverlay(); });
  const nameBox=document.createElement('input'); nameBox.className='layerName'; nameBox.value=L.name; nameBox.addEventListener('click',(e)=>e.stopPropagation()); nameBox.addEventListener('input',()=> L.name=nameBox.value);
  const colorBox=document.createElement('input'); colorBox.type='color'; colorBox.value=L.color; colorBox.title='Layer color'; colorBox.addEventListener('click',(e)=>e.stopPropagation()); colorBox.addEventListener('input',()=>{ L.color=colorBox.value; redrawOverlay(); });
  const right=document.createElement('div'); right.style.display='flex'; right.style.gap='6px'; right.style.alignItems='center'; right.appendChild(colorBox);
  row.appendChild(eye); row.appendChild(nameBox); row.appendChild(right); layerList.appendChild(row);
  const opRowWrap=document.createElement('div'); opRowWrap.style.marginTop='6px'; opRowWrap.style.display='grid'; opRowWrap.style.gridTemplateColumns='auto 1fr auto'; opRowWrap.style.alignItems='center'; opRowWrap.style.gap='8px';
  const opLabel=document.createElement('label'); opLabel.textContent='Opacity'; const opOutput=document.createElement('output'); opOutput.textContent=(L.opacity).toFixed(2);
  const opSlider=document.createElement('input'); opSlider.type='range'; opSlider.min=0; opSlider.max=100; opSlider.step=1; opSlider.value=Math.round(L.opacity*100);
  opSlider.addEventListener('input',()=>{ L.opacity=(+opSlider.value)/100; opOutput.textContent=L.opacity.toFixed(2); redrawOverlay(); });
  opRowWrap.appendChild(opLabel); opRowWrap.appendChild(opSlider); opRowWrap.appendChild(opOutput); layerList.appendChild(opRowWrap);
}); }

function refreshNetsList(){
  if(!netsList) return;
  netsList.innerHTML='';
  netLabels.forEach((n,idx)=>{
    const row=document.createElement('div');
    row.className='layerItem'+(idx===activeNet?' active':'');
    row.addEventListener('click',()=>{ activeNet=idx; refreshNetsList(); applyArrowsForActiveNet(); });

    const name=document.createElement('input');
    name.className='layerName'; name.value=n.name;
    name.addEventListener('click',e=>e.stopPropagation());
    name.addEventListener('input',()=>{ n.name=name.value; redrawOverlay(); });

    const stats=document.createElement('div');
    stats.className='hint';
    stats.textContent=`samples=${n.samples.length}`;

    const right=document.createElement('div');
    right.style.display='flex'; right.style.gap='6px'; right.style.alignItems='center';

    const color=document.createElement('input');
    color.type='color'; color.value=n.color; color.title='Net color';
    color.addEventListener('click',e=>e.stopPropagation());
    color.addEventListener('input',()=>{ n.color=color.value; redrawOverlay(); });

    const sizeLabel=document.createElement('label'); sizeLabel.textContent='Size';
    const size=document.createElement('input'); size.type='range'; size.min=10; size.max=48; size.step=1; size.value=n.size|0; size.style.width='120px';
    const sizeOut=document.createElement('output'); sizeOut.textContent=String(n.size|0);
    size.addEventListener('input',()=>{ n.size=+size.value; sizeOut.textContent=size.value; redrawOverlay(); });

    const zoomBtn=document.createElement('button'); zoomBtn.textContent='Zoom';
    zoomBtn.addEventListener('click',(e)=>{ e.stopPropagation(); centerOn(n.seed.x, n.seed.y); });

    right.appendChild(color);
    right.appendChild(sizeLabel);
    right.appendChild(size);
    right.appendChild(sizeOut);
    right.appendChild(zoomBtn);

    row.appendChild(name);
    row.appendChild(stats);
    row.appendChild(right);
    netsList.appendChild(row);
  });
}

addLayerBtn.addEventListener('click',()=>{ if(!imgLoaded) return alert('Load an image first.'); layers.splice(activeLayer+1,0,newLayer('Layer '+(layers.length+1))); activeLayer++; refreshLayerList(); redrawOverlay(); logHistory('Added new layer'); });
delLayerBtn.addEventListener('click',()=>{ if(layers.length<=1) return alert('Keep at least one layer.'); const removed=activeLayer; layers.splice(activeLayer,1); segments=segments.filter(s=>s.layer!==removed).map(s=>{ if(s.layer>removed) s.layer--; return s; }); activeLayer=Math.max(0,activeLayer-1); refreshLayerList(); redrawOverlay(); logHistory('Deleted layer (and its segments)'); });
dupLayerBtn.addEventListener('click',()=>{ const L=layers[activeLayer]; const copy=newLayer(L.name+' copy'); copy.color=L.color; copy.opacity=L.opacity; copy.mask.set(L.mask); layers.splice(activeLayer+1,0,copy); const newIndex=activeLayer+1; segments.push(...segments.filter(s=>s.layer===activeLayer).map(s=>({x1:s.x1,y1:s.y1,x2:s.x2,y2:s.y2,thick:s.thick,layer:newIndex}))); activeLayer=newIndex; refreshLayerList(); redrawOverlay(); logHistory('Duplicated layer (with segments)'); });

clearActiveBtn.addEventListener('click',()=>{ if(!layers.length) return; layers[activeLayer].mask.fill(0); segments=segments.filter(s=>s.layer!==activeLayer); redrawOverlay(); logHistory('Cleared active layer (mask + segments)'); });
syncLayerStyleBtn.addEventListener('click',()=>{ if(!layers.length) return; const L=layers[activeLayer]; L.color=color.value; L.opacity=(+alpha.value)/100; refreshLayerList(); redrawOverlay(); logHistory('Applied default style to active layer'); });

function runCommand(cmd){ cmd=(cmd||'').trim(); if(!cmd) return; function writeln(s){ consoleOut.textContent+=s+'\\n'; consoleOut.scrollTop=consoleOut.scrollHeight; } writeln('> '+cmd);
  if(cmd==='help'){ writeln('Commands: help, clear, stats, layers, symbols, nets'); }
  else if(cmd==='clear'){ consoleOut.textContent=''; }
  else if(cmd==='stats'){ writeln(`Image ${imgW}x${imgH}, layers=${layers.length}, active=${activeLayer+1}, symbols=${symbols.length}, nets=${netLabels.length}`); }
  else if(cmd==='layers'){ layers.forEach((L,i)=> writeln(`${i+1}. ${L.name} [${L.visible?'vis':'hid'}] color=${L.color} opacity=${L.opacity.toFixed(2)}`)); }
  else if(cmd==='symbols'){ symbols.forEach((s,i)=> writeln(`${i+1}. ${s.type} at (${s.x|0},${s.y|0}) size=${s.size} rot=${s.rot||0} color=${s.color||'#000'} label=${s.label||''}`)); }
  else if(cmd==='nets'){ netLabels.forEach((n,i)=> writeln(`${i+1}. ${n.name} samples=${n.samples.length}`)); if(!netLabels.length) writeln('(no nets)'); }
  else { writeln('Unknown command. Try "help".'); } }
consoleRun.addEventListener('click',()=> runCommand(consoleIn.value));
consoleIn.addEventListener('keydown',(e)=>{ if(e.key==='Enter') runCommand(consoleIn.value); });
clearHistoryBtn.addEventListener('click',()=>{ history=[]; historyList.innerHTML=''; logHistory('History cleared'); });

function hitTestAnnotation(ix,iy){
  for(let i=annotations.length-1;i>=0;i--){
    const a=annotations[i]; const size=Math.max(10, +a.size||18);
    const m=document.createElement('canvas').getContext('2d'); m.font=`${size}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif`;
    const w=Math.max(10, m.measureText(a.text||'').width); const h=Math.max(10, size*1.2);
    if(ix>=a.x && ix<=a.x+w && iy>=a.y-h/2 && iy<=a.y+h/2) return i;
  }
  return -1;
}
function hitTestSegment(ix,iy){
  let best=-1, bestD=6;
  for(let i=0;i<segments.length;i++){
    const s=segments[i];
    const d = distPointToSegment(ix,iy, s.x1,s.y1,s.x2,s.y2);
    if(d<bestD){ bestD=d; best=i; }
  }
  return best;
}
function distPointToSegment(px,py,x1,y1,x2,y2){
  const vx=x2-x1, vy=y2-y1, wx=px-x1, wy=py-y1;
  const c1 = vx*wx + vy*wy;
  if(c1<=0) return Math.hypot(px-x1,py-y1);
  const c2 = vx*vx + vy*vy;
  if(c2<=c1) return Math.hypot(px-x2,py-y2);
  const b = c1 / c2;
  const bx = x1 + b*vx, by = y1 + b*vy;
  return Math.hypot(px-bx, py-by);
}

function eraseAt(ix,iy,size){ if(!layers.length) return; clearMask(layers[activeLayer].mask, Math.round(ix), Math.round(iy), Math.max(1, Math.round(size/2))); }
function eraseLineTo(ix,iy,size){ if(!layers.length) return; if(!lastErase){ lastErase={x:ix,y:iy}; eraseAt(ix,iy,size); return; } const steps=Math.ceil(Math.hypot(ix-lastErase.x, iy-lastErase.y) / 1); for(let t=0;t<=steps;t++){ const x=lerp(lastErase.x,ix,t/steps); const y=lerp(lastErase.y,iy,t/steps); eraseAt(x,y,size); } lastErase={x:ix,y:iy}; }

document.getElementById('download').addEventListener('click',()=>{
  if(!imgLoaded) return;
  const exportCanvas=document.createElement('canvas'); exportCanvas.width=imgW; exportCanvas.height=imgH; const ex=exportCanvas.getContext('2d');
  ex.drawImage(imgBitmap,0,0);
  for(const L of layers){ if(!L.visible) continue; const a=Math.round(clamp(L.opacity,0,1)*255); let R=255,G=0,B=0; try{ R=parseInt(L.color.slice(1,3),16); G=parseInt(L.color.slice(3,5),16); B=parseInt(L.color.slice(5,7),16);}catch(_){}
    const data=maskImageData.data, mask=L.mask; for(let i=0,j=0;i<mask.length;i++,j+=4){ if(mask[i]){ data[j]=R; data[j+1]=G; data[j+2]=B; data[j+3]=a; } else { data[j]=data[j+1]=data[j+2]=data[j+3]=0; } } maskCtx.putImageData(maskImageData,0,0); ex.drawImage(maskCanvas,0,0);
  }
  for(const seg of segments){ const L=layers[seg.layer]||layers[0]; if(!L||!L.visible) continue; ex.save(); ex.globalAlpha=Math.max(0,Math.min(1,L.opacity)); ex.strokeStyle=L.color||'#ff0000'; ex.lineWidth=Math.max(1,seg.thick||(+thickness.value|0)); ex.beginPath(); ex.moveTo(seg.x1,seg.y1); ex.lineTo(seg.x2,seg.y2); ex.stroke(); ex.restore(); }
  for(const s of symbols){ const img=symbolImages[s.type]; if(!img) continue; const w=s.size,h=s.size*(img.height/Math.max(1,img.width));
    tintCanvas.width=Math.max(1,Math.round(w)); tintCanvas.height=Math.max(1,Math.round(h)); tintCtx.clearRect(0,0,tintCanvas.width,tintCanvas.height); tintCtx.drawImage(img,0,0,tintCanvas.width,tintCanvas.height); tintCtx.globalCompositeOperation='source-atop'; tintCtx.fillStyle=s.color||'#000'; tintCtx.fillRect(0,0,tintCanvas.width,tintCanvas.height); tintCtx.globalCompositeOperation='source-over';
    ex.save(); ex.translate(s.x,s.y); ex.rotate((s.rot||0)*Math.PI/180); ex.drawImage(tintCanvas,-w/2,-h/2,w,h); ex.rotate(-(s.rot||0)*Math.PI/180);
    if(s.label){ ex.font=`${s.labelSize||16}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, sans-serif`; ex.textBaseline='middle'; ex.fillStyle=s.labelColor||'#000'; ex.strokeStyle='rgba(255,255,255,0.9)'; ex.lineWidth=3; const dx=w/2+8+(s.labelDx||0), dy=(s.labelDy||0); ex.strokeText(s.label,dx,dy); ex.fillText(s.label,dx,dy); }
    ex.restore();
  }
  drawAnnotationsToCtx(ex,false);
  drawNetLabels(ex,false);
  const link=document.createElement('a'); link.download='schematic_highlight.png'; link.href=exportCanvas.toDataURL('image/png'); link.click(); logHistory('Exported PNG (with net labels)');
});

function createTestSvg(){ const svg=`<svg xmlns='http://www.w3.org/2000/svg' width='400' height='260' viewBox='0 0 400 260'><rect width='100%' height='100%' fill='white'/><g stroke='black' stroke-width='3' fill='none'><line x1='20' y1='40' x2='380' y2='40'/><rect x='40' y='100' width='120' height='60'/><circle cx='300' cy='130' r='30'/></g></svg>`; return 'data:image/svg+xml;utf8,'+encodeURIComponent(svg); }
function runSelfTests(){ testLog.textContent='Running…'; function log(line,ok=true){ const el=document.createElement('div'); el.textContent=(ok?'PASS: ':'FAIL: ')+line; el.className=ok?'pass':'fail'; testLog.appendChild(el); }
  const prevSnap=+snap.value; const setSnap=v=>{snap.value=v; snapVal.textContent=v;}; const prevSegment=segmentMode.checked; const prevThickness=+thickness.value;
  loadFromUrl(createTestSvg(), ()=>{ setSnap(6); segmentMode.checked=true; traceSegment(30,40,{clear:true}); let count1=0; for(let i=0;i<layers[activeLayer].mask.length;i++) count1+=layers[activeLayer].mask[i]; testLog.textContent=''; log('Top line traced (pixel count > 500)', count1>500);
    eraseAt(30,40,20); redrawOverlay(); let after=0; for(let i=0;i<layers[activeLayer].mask.length;i++) after+=layers[activeLayer].mask[i]; log('Eraser reduced pixel count', after<count1);
    symbols.push({type:'resistor', x:200, y:120, size:64, rot:0, layer:activeLayer, color:'#ff0000', label:'R1', labelSize:16, labelColor:'#000'}); redrawOverlay(); log('Symbol added + colored + labeled', symbols.length>0);
    const thr=computeAutoThreshold(rawImageData); log('Auto-threshold returns 20..220', thr>=20 && thr<=220);
    setSnap(prevSnap); segmentMode.checked=prevSegment; thickness.value=prevThickness; thicknessVal.textContent=String(prevThickness); loadFromUrl(SAMPLE_URL);
  });
}
document.getElementById('runTests').addEventListener('click', runSelfTests);

function centerOn(ix,iy){
  const [sx,sy]=imgToScreen(ix,iy);
  panX += (view.width*0.5 - sx);
  panY += (view.height*0.5 - sy);
  drawBase(); redrawOverlay();
}

// ================== Net labels + Continuity ==================
function getSymbolPins(sym){
  const img=symbolImages[sym.type]; if(!img) return [];
  const w=sym.size; const h=sym.size*(img.height/Math.max(1,img.width));
  const L={x:-w/2,y:0}, R={x:w/2,y:0}; const rot=(sym.rot||0)*Math.PI/180; const cos=Math.cos(rot), sin=Math.sin(rot);
  function T(local){ const xr=local.x*cos - local.y*sin; const yr=local.x*sin + local.y*cos; return {x:sym.x+xr, y:sym.y+yr}; }
  switch(sym.type){
    case 'resistor': case 'capacitor': case 'diode': case 'led': case 'inductor': return [T(L), T(R)];
    case 'ground': return [T({x:0,y:-h*0.25})];
    case 'opamp': return [T({x:-w*0.45,y:-h*0.2}), T({x:-w*0.45,y:h*0.2}), T({x:w*0.40,y:0})];
    default: return [];
  }
}
function hitTestNearestPin(sx,sy){
  let best=null, bestD=1e9;
  for(let i=0;i<symbols.length;i++){
    const pins=getSymbolPins(symbols[i]);
    for(let p=0;p<pins.length;p++){
      const [px,py]=imgToScreen(pins[p].x, pins[p].y);
      const d=Math.hypot(px-sx, py-sy);
      if(d<bestD){ bestD=d; best={symIdx:i,pinIdx:p,x:pins[p].x,y:pins[p].y}; }
    }
  }
  return (bestD<=14)?best:null;
}
function computeNetComponent(sx,sy){
  const threshold=+thresh.value; const seed = findNearestInkRobust(sx|0,sy|0,+snap.value,threshold);
  if(!seed) return null;
  const MAX=(+limit.value)*1000; const seen=new Uint8Array(imgW*imgH); const q=[seed.y*imgW+seed.x]; seen[q[0]]=1;
  const pixels=[]; let steps=0;
  while(q.length && steps<MAX){
    const cur=q.shift(); pixels.push(cur);
    const cx=cur%imgW, cy=(cur/imgW)|0;
    for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue; const nIdx=ny*imgW+nx; if(seen[nIdx]) continue; if(isInk(nx,ny,threshold)){ seen[nIdx]=1; q.push(nIdx); } } }
    steps++;
  }
  const target=32; const stride=Math.max(20, Math.floor(pixels.length/target)); const samples=[];
  for(let i=0;i<pixels.length;i+=stride){ const idx=pixels[i]; samples.push({x:(idx%imgW), y:((idx/imgW)|0)}); }
  return { id:'net-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,7), samples, seed:{x:seed.x,y:seed.y} };
}
function labelNetAt(ix,iy,presetName=null){
  const comp=computeNetComponent(ix,iy);
  if(!comp){ alert('No line pixels near click. Try adjusting Snap or Threshold.'); return; }
  let name=(presetName??prompt('Net name (e.g., VCC, GND, NET1):','NET'))||''; name=name.trim(); if(!name) return;
  netLabels.push({ id:comp.id, name, color:labelColor.value||'#6bb2ff', size:+labelSize.value||18, samples:comp.samples, seed:comp.seed, arrows: readArrowsPinnedUI() });
  activeNet = netLabels.length - 1;
  logHistory(`Net label "${name}" added near (${Math.round(ix)}, ${Math.round(iy)})`); refreshNetsList(); applyArrowsForActiveNet(); redrawOverlay();
}
function drawNetLabels(ctx,transformed){
  if(!showNetLabelsChk || !showNetLabelsChk.checked) { if (window.__setArrowAnimActive) window.__setArrowAnimActive(false); return; }
  if(!netLabels.length) { if (window.__setArrowAnimActive) window.__setArrowAnimActive(false); return; }
  ctx.save();
  let anySelected = false;
  for(const n of netLabels){
    const color = n.color || '#6bb2ff';
    const sizePx = Math.max(10, +(n.size||18));

    // Pick a seed: prefer n.seed; else first sample
    const sample0 = (n.samples && n.samples.length) ? n.samples[0] : null;
    const seed = n.seed || sample0;
    if (!seed) continue;

    // Label at the sample0 (or seed) position
    const px = sample0 ? sample0.x : seed.x;
    const py = sample0 ? sample0.y : seed.y;
    const sx = transformed ? (px - imgW/2) : px;
    const sy = transformed ? (py - imgH/2) : py;

    try {
      ctx.save();
      ctx.font = `${sizePx}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial`;
      ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=3;
      ctx.fillStyle=color;
      ctx.strokeText(n.name||'NET', sx, sy);
      ctx.fillText(n.name||'NET', sx, sy);
      ctx.restore();
    } catch(_) {}

    // Chevrons snapped to ink using BFS from the seed
    try {
      if (typeof computeChevronPositionsForNet === 'function') {
        const chevs = computeChevronPositionsForNet(seed, 80); // spacing in screen px
        for (const c of chevs.pts){
          const cx = transformed ? (c.x - imgW/2) : c.x;
          const cy = transformed ? (c.y - imgH/2) : c.y;
          window.drawChevron(ctx, cx, cy, c.theta, 10, color);
        }
      }
    } catch(_) {}

    if (n.selected) anySelected = true;
  }
  if (window.__setArrowAnimActive) window.__setArrowAnimActive(anySelected);
  ctx.restore();

}
function continuityByNetName(ax,ay,bx,by){
  let an=null,bn=null; const near=10;
  for(const n of netLabels){
    for(const s of n.samples){
      if(!an && Math.abs(s.x-ax)<=near && Math.abs(s.y-ay)<=near) an=n.name;
      if(!bn && Math.abs(s.x-bx)<=near && Math.abs(s.y-by)<=near) bn=n.name;
      if(an && bn) break;
    }
    if(an && bn) break;
  }
  if(an && bn && an===bn) return {pass:true, via:'net-name', name:an};
  return {pass:false, via:null};
}
function testContinuity(pinA,pinB){
  const threshold=+thresh.value;
  const byName=continuityByNetName(pinA.x,pinA.y,pinB.x,pinB.y);
  if(byName.pass){ contResult={pass:true,steps:0,via:'net-name'}; logHistory(`Continuity PASS (net "${byName.name}")`); redrawOverlay(); return; }
  const a=findNearestInk(pinA.x|0,pinA.y|0,+snap.value,threshold);
  const b=findNearestInk(pinB.x|0,pinB.y|0,+snap.value,threshold);
  if(!a||!b){ contResult={pass:false,steps:0,via:'bfs'}; logHistory('Continuity FAIL (no wire near one or both pins)'); redrawOverlay(); return; }
  const MAX=(+limit.value)*1000; const seen=new Uint8Array(imgW*imgH); const q=[a.y*imgW+a.x]; seen[q[0]]=1; const goal={x:b.x,y:b.y}; const reach=Math.max(1,(+snap.value)|0); let steps=0,pass=false;
  while(q.length && steps<MAX){
    const cur=q.shift(); const cx=cur%imgW, cy=(cur/imgW)|0;
    if(Math.abs(cx-goal.x)<=reach && Math.abs(cy-goal.y)<=reach){ pass=true; break; }
    for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(dx===0&&dy===0) continue; const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue; const nIdx=ny*imgW+nx; if(seen[nIdx]) continue; if(isInk(nx,ny,threshold)){ seen[nIdx]=1; q.push(nIdx); } } }
    steps++;
  }
  contResult={pass,steps,via:'bfs'}; logHistory(`Continuity ${pass?'PASS':'FAIL'} (BFS visited ~${steps} px)`); redrawOverlay();
}
function drawContinuityUI(ctx){
  if(!contMode) return;
  ctx.save(); ctx.imageSmoothingEnabled=false; applyViewTransform(ctx);
  const r=3/viewScale; ctx.lineWidth=2/viewScale;
  for(let i=0;i<symbols.length;i++){
    const pins=getSymbolPins(symbols[i]);
    for(let p=0;p<pins.length;p++){
      const sel=(contSel1&&contSel1.symIdx===i&&contSel1.pinIdx===p)||(contSel2&&contSel2.symIdx===i&&contSel2.pinIdx===p);
      ctx.beginPath(); ctx.fillStyle= sel?'#35c46a':'#121a29'; ctx.strokeStyle= sel?'#35c46a':'#6bb2ff';
      ctx.arc(pins[p].x - imgW/2, pins[p].y - imgH/2, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    }
  }
  if(contSel1 && contSel2){ ctx.setLineDash([6,4]); ctx.lineWidth=2/viewScale; ctx.strokeStyle= (contResult&&contResult.pass)?'#35c46a':'#ff6b6b'; ctx.beginPath(); ctx.moveTo(contSel1.x - imgW/2, contSel1.y - imgH/2); ctx.lineTo(contSel2.x - imgW/2, contSel2.y - imgH/2); ctx.stroke(); ctx.setLineDash([]); }
  ctx.restore();
}
function toggleNetLabelMode(on){ netLabelMode=(on===undefined?!netLabelMode:!!on); netLabelBtn?.classList.toggle('active',netLabelMode); if(netLabelMode){ panMode=false; eraserMode=false; lineMode=false; textMode=false; eraserToggle?.classList?.remove('active'); lineToggle?.classList?.remove('active'); textModeBtn?.classList?.remove('active'); } }
function toggleContMode(on){ contMode=(on===undefined?!contMode:!!on); contToggleBtn?.classList?.toggle('active',contMode); if(contMode){ panMode=false; eraserMode=false; lineMode=false; textMode=false; eraserToggle?.classList?.remove('active'); lineToggle?.classList?.remove('active'); textModeBtn?.classList?.remove('active'); } else { contSel1=contSel2=contResult=null; } redrawOverlay(); }
netLabelBtn?.addEventListener('click',()=> toggleNetLabelMode());
try{ document.querySelector('[data-tab="#tab-nets"]').addEventListener('click', ()=> setTimeout(applyArrowsForActiveNet,0)); }catch(_e){}
contToggleBtn?.addEventListener('click',()=> toggleContMode());
function continuityMouseDown(e){
  if(!contMode) return;
  if(e.button===1) return;
  const hit=hitTestNearestPin(e.offsetX,e.offsetY);
  if(!hit){ logHistory('Continuity: click closer to a pin.'); e.preventDefault(); e.stopPropagation(); return; }
  if(!contSel1){ contSel1=hit; redrawOverlay(); }
  else if(!contSel2){ contSel2=hit; testContinuity(contSel1,contSel2); }
  else { contSel1=hit; contSel2=null; contResult=null; redrawOverlay(); }
  e.preventDefault(); e.stopPropagation();
}

// ===== Arrows ↔ Nets wiring helpers =====
function readArrowsPinnedUI(){
  const $ = (id)=>document.getElementById(id);
  return {
    enable: !!($('chkChevronEnable')?.checked),
    marching: !!($('chkChevronMarch')?.checked),
    labelShow: !!($('chkLabelShow')?.checked),
    spacing: +($('rngChevronSpace')?.value||52),
    size: +($('rngChevronSize')?.value||18),
    speed: +($('rngChevronSpeed')?.value||2),
    labelSize: +($('rngLabelSize')?.value||14),
    style: ($('selArrowStyle')?.value||'triangle'),
    startOffset: +($('rngStartOffset')?.value||12),
    autoDensity: !!($('chkAutoDensity')?.checked),
    color: ($('colArrow')?.value||'#6bb2ff'),
    labelBg: ($('colLabelBg')?.value||'#141820'),
    labelFg: ($('colLabelFg')?.value||'#e8eef7')
  };
}
function writeArrowsPinnedUI(cfg){
  if(!cfg) return;
  const setV=(id,v)=>{ const el=document.getElementById(id); if(!el) return; if(el.type==='checkbox'){ el.checked=!!v; } else { el.value=String(v); } };
  const setO=(id,v)=>{ const out=document.getElementById(id); if(out) out.textContent=String(v); };
  setV('chkChevronEnable', !!cfg.enable);
  setV('chkChevronMarch', !!cfg.marching);
  setV('chkLabelShow', !!cfg.labelShow);
  setV('rngChevronSpace', +cfg.spacing); setO('outChevronSpace', +cfg.spacing);
  setV('rngChevronSize', +cfg.size); setO('outChevronSize', +cfg.size);
  setV('rngChevronSpeed', +cfg.speed); setO('outChevronSpeed', +cfg.speed);
  setV('rngLabelSize', +cfg.labelSize); setO('outLabelSize', +cfg.labelSize);
  setV('selArrowStyle', (cfg.style||'triangle'));
  setV('rngStartOffset', +cfg.startOffset); setO('outStartOffset', +cfg.startOffset);
  setV('chkAutoDensity', !!cfg.autoDensity);
  setV('colArrow', cfg.color||'#6bb2ff');
  setV('colLabelBg', cfg.labelBg||'#141820');
  setV('colLabelFg', cfg.labelFg||'#e8eef7');
}
function applyArrowsForActiveNet(){
  try{
    if(typeof ensureReady==='function' && !ensureReady()) return;
    if(!Array.isArray(netLabels) || netLabels.length===0) return;
    if(activeNet<0 || activeNet>=netLabels.length) return;
    const n = netLabels[activeNet];
    n.arrows = n.arrows || readArrowsPinnedUI();
    writeArrowsPinnedUI(n.arrows);
    const path = (n.samples||[]).map(pt=>({x:pt.x, y:pt.y}));
    if(path.length>1){
      window.__arrows_setPath?.(path, n.name||'NET', n.arrows?.color||n.color||'#6bb2ff');
      if(typeof window.__setArrowAnimActive==='function'){
        window.__setArrowAnimActive(!!n.arrows.marching && !!n.arrows.enable);
      }
      if(window.state){ window.state.needsRedraw = true; (window.drawFrame||function(){})(); }
    }
  }catch(err){ console.error(err); }
}
// ===== end helpers =====

function netLabelClick(e){
  if(!netLabelMode) return;
  const [ix,iy]=screenToImg(e.offsetX,e.offsetY);
  labelNetAt(ix,iy);
  e.preventDefault(); e.stopPropagation();
}
view.addEventListener('mousedown', continuityMouseDown, true);
view.addEventListener('click',      netLabelClick,      true);

// Nets tab controls
addNetBtn?.addEventListener('click',()=>{ toggleNetLabelMode(true); logHistory('Net Label mode enabled — click a wire to create'); });
delNetBtn?.addEventListener('click',()=>{
  if(activeNet<0 || activeNet>=netLabels.length) return;
  const rm = netLabels.splice(activeNet,1);
  activeNet = Math.max(0, Math.min(activeNet, netLabels.length-1));
  refreshNetsList(); redrawOverlay();
  logHistory(`Deleted net "${rm[0]?.name||''}"`);
});
exportNetsBtn?.addEventListener('click',()=>{
  const data = netLabels.map(n=>({name:n.name,color:n.color,size:n.size,seed:n.seed,sampleCount:n.samples.length}));
  const blob = new Blob([JSON.stringify({nets:data},null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='nets.json'; a.click(); URL.revokeObjectURL(url);
  logHistory('Exported nets.json');
});


// --- Manual Arrows mode toggle ---
function toggleArrowsMode(on){
  arrowsMode = (on===undefined ? !arrowsMode : !!on);
  if(arrowsMode){
    panMode=false; eraserMode=false; lineMode=false; textMode=false; netLabelMode=false; contMode=false; highlightMode=false;
    panToggle?.classList?.remove('active'); eraserToggle?.classList?.remove('active');
    lineToggle?.classList?.remove('active'); textModeBtn?.classList?.remove('active');
    netLabelBtn?.classList?.remove('active'); contToggleBtn?.classList?.remove('active');
    highlightToggle?.classList?.remove('active');
    logHistory('Manual Arrows: click a wire to draw arrows (uses Nets → Arrows settings).');
  }
  syncToolButtons?.();
}

// ===== Top toolbar wiring =====
const topPan = document.getElementById('topPan');
const topHighlight = document.getElementById('topHighlight');
const topText = document.getElementById('topText');
const topEraser = document.getElementById('topEraser');
const topLine = document.getElementById('topLine');
const topNet = document.getElementById('topNet');
const topCont = document.getElementById('topCont');
const topArrows = document.getElementById('topArrows');

function syncToolButtons(){
  topPan?.classList.toggle('active', !!panMode);
  topHighlight?.classList.toggle('active', !!highlightMode);
  topText?.classList.toggle('active', !!textMode);
  topEraser?.classList.toggle('active', !!eraserMode);
  topLine?.classList.toggle('active', !!lineMode);
  topNet?.classList.toggle('active', !!netLabelMode);
  topCont?.classList.toggle('active', !!contMode);
  try{ topArrows?.classList.toggle('active', !!arrowsMode); }catch(_){}
}

// Hook up top buttons to same actions
topPan?.addEventListener('click', ()=>{ panToggle?.click(); syncToolButtons(); });
topArrows?.addEventListener('click', ()=>{ toggleArrowsMode(); syncToolButtons(); });
topHighlight?.addEventListener('click', ()=>{ highlightToggle?.click(); syncToolButtons(); });
topText?.addEventListener('click', ()=>{ textModeBtn?.click(); syncToolButtons(); });
topEraser?.addEventListener('click', ()=>{ eraserToggle?.click(); syncToolButtons(); });
topLine?.addEventListener('click', ()=>{ lineToggle?.click(); syncToolButtons(); });
topNet?.addEventListener('click', ()=>{ netLabelBtn?.click(); syncToolButtons(); });
topCont?.addEventListener('click', ()=>{ contToggleBtn?.click(); syncToolButtons(); });
eraserToggle?.addEventListener('click', toggleEraser);

// --- Manual Arrows click handler ---


function manualArrowsClick(e){
  if(!arrowsMode) return;
  e.preventDefault(); e.stopPropagation();
  if(!imgLoaded) return;
  try{
    const sx = e.offsetX, sy = e.offsetY;
    const [ix,iy] = screenToImg(sx, sy);
    let usedOverlay = false;

    // If highlight exists under cursor, adopt from overlay
    if(__overlayHasRedAt(sx, sy)){
      const p = fromOverlay();
      if(p && p.length>1){
        window.__arrows_setPath?.(p);
        usedOverlay = true;
        logHistory?.('Manual Arrows: path set from existing highlight.');
      }
    }

    // If no overlay path, run the old tracer at the click point (do not clear), then adopt overlay
    if(!usedOverlay && typeof traceSegment==='function'){
      traceSegment(ix, iy, {clear:false});
      const p2 = fromOverlay?.();
      if(p2 && p2.length>1){
        window.__arrows_setPath?.(p2);
        usedOverlay = true;
        logHistory?.('Manual Arrows: path set via highlight tracer.');
      }
    }

    // Fallback: robust net sampler if needed
    if(!usedOverlay && typeof computeNetComponent==='function'){
      const comp = computeNetComponent(ix, iy);
      if(comp?.samples?.length>=2){
        const pathImg = comp.samples.map(pt=>({x:pt.x,y:pt.y}));
        window.__arrows_setPath?.(pathImg);
        logHistory?.('Manual Arrows: path set from net samples.');
        usedOverlay = true;
      }
    }

    if(usedOverlay){
      if(UI?.march?.checked){ window.__setArrowAnimActive?.(true); }
      state.needsRedraw = true; drawFrame?.();
      return;
    }

    logHistory?.('Manual Arrows: no wire near click. Try Snap 12–18 and Threshold ~210–235, then click closer.');
  }catch(err){ console.error(err); }
}


view.addEventListener('click', manualArrowsClick, true);

// ===== Basic Undo/Redo (snapshot of vector + mask state, capped) =====
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const UNDO_LIMIT = 20;
let undoStack = [];
let redoStack = [];

function cloneState(){
  // clone layers (including mask), segments, annotations, symbols, nets, view
  const L = layers.map(L=>({id:L.id,name:L.name,visible:L.visible,opacity:L.opacity,color:L.color,mask:new Uint8Array(L.mask)}));
  const state = {
    imgW, imgH, origW, origH,
    viewScale, panX, panY,
    layers: L,
    activeLayer,
    annotations: JSON.parse(JSON.stringify(annotations)),
    symbols: JSON.parse(JSON.stringify(symbols)),
    segments: JSON.parse(JSON.stringify(segments)),
    netLabels: JSON.parse(JSON.stringify(netLabels)),
    activeNet
  };
  return state;
}
function restoreState(state){
  if(!state) return;
  imgW = state.imgW; imgH = state.imgH; origW = state.origW; origH = state.origH;
  viewScale = state.viewScale; panX = state.panX; panY = state.panY;
  layers = state.layers.map(L=>({id:L.id,name:L.name,visible:L.visible,opacity:L.opacity,color:L.color,mask:new Uint8Array(L.mask)}));
  activeLayer = state.activeLayer;
  annotations = state.annotations||[];
  symbols = state.symbols||[];
  segments = state.segments||[];
  netLabels.splice(0, netLabels.length, ...(state.netLabels||[]));
  activeNet = state.activeNet||0;
  refreshLayerList();
  refreshNetsList?.();
  drawBase(); redrawOverlay();
}

function pushUndo(label=''){
  try {
    const snap = cloneState();
    undoStack.push(snap);
    if(undoStack.length>UNDO_LIMIT) undoStack.shift();
    // clearing redo on new action
    redoStack = [];
  } catch(e){ console.warn('Undo snapshot failed', e); }
}
function doUndo(){
  if(!undoStack.length) return;
  const cur = cloneState();
  const prev = undoStack.pop();
  redoStack.push(cur);
  restoreState(prev);
}
function doRedo(){
  if(!redoStack.length) return;
  const cur = cloneState();
  const next = redoStack.pop();
  undoStack.push(cur);
  restoreState(next);
}
undoBtn?.addEventListener('click', doUndo);
redoBtn?.addEventListener('click', doRedo);
window.addEventListener('keydown',(e)=>{
  const tgt = e.target; const typing = tgt && (tgt.tagName==='INPUT' || tgt.tagName==='TEXTAREA' || tgt.isContentEditable);
  if(typing) return;
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); if(e.shiftKey){ doRedo(); } else { doUndo(); } }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); doRedo(); }
});

// Inject pushUndo into key mutating paths
const _traceFlood = traceFlood;
traceFlood = function(ix,iy,opts){ pushUndo('traceFlood'); return _traceFlood(ix,iy,opts); };
const _traceSegment = traceSegment;
traceSegment = function(ix,iy,opts){ pushUndo('traceSegment'); return _traceSegment(ix,iy,opts); };
const _clearClick = document.getElementById('clear')?.onclick;
document.getElementById('clear').addEventListener('click', ()=> pushUndo('clear'), {once:false});
const _addLayerBtn = addLayerBtn?.onclick;

// On mouseup after dragging/moving entities, push once
window.addEventListener('mouseup', ()=>{
  if(draggingSym || draggingSeg || draggingAnn || (lineStart||lineEnd)){ pushUndo('mouseup'); }
});

// When dropping a symbol or text, push after change
view.addEventListener('drop', ()=>{ pushUndo('drop'); }, {capture:true});

// After commitEditor, also push (monkey-patch commitEditor)
const __commitEditor = commitEditor;
commitEditor = function(){ const r = __commitEditor(); pushUndo('editText'); return r; };

// ===== Project Save/Load =====
const saveProjectBtn = document.getElementById('saveProject');
const openProjectBtn = document.getElementById('openProjectBtn');
const openProjectInput = document.getElementById('openProject');

function exportProject(){
  const data = {
    meta: { v: 1, when: Date.now() },
    image: imgBitmap?.toDataURL ? imgBitmap.toDataURL('image/png') : null,
    imgW, imgH, origW, origH,
    view: { viewScale, panX, panY },
    layers: layers.map(L=>({id:L.id,name:L.name,visible:L.visible,opacity:L.opacity,color:L.color,mask: Array.from(L.mask) })),
    activeLayer,
    annotations, symbols, segments, netLabels, activeNet
  };
  const blob = new Blob([JSON.stringify(data)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'schematic-project.json'; a.click(); URL.revokeObjectURL(url);
  logHistory('Exported schematic-project.json');
}
async function importProjectFile(file){
  const text = await file.text();
  const data = JSON.parse(text);
  // Rebuild bitmap from embedded image if available
  if(data.image){
    const img = new Image();
    img.onload = ()=>{
      const c = document.createElement('canvas'); c.width = img.naturalWidth; c.height = img.naturalHeight;
      const cctx = c.getContext('2d'); cctx.drawImage(img,0,0);
      ingestBitmap(c, img.naturalWidth, img.naturalHeight);
      // restore state fields
      viewScale = data.view?.viewScale || viewScale; panX = data.view?.panX||0; panY = data.view?.panY||0;
      layers = (data.layers||[]).map(L=>({id:L.id,name:L.name,visible:L.visible,opacity:L.opacity,color:L.color,mask:new Uint8Array(L.mask||[]) }));
      activeLayer = data.activeLayer||0;
      annotations = data.annotations||[];
      symbols = data.symbols||[];
      segments = data.segments||[];
      netLabels.splice(0, netLabels.length, ...(data.netLabels||[]));
      activeNet = data.activeNet||0;
      refreshLayerList(); refreshNetsList?.(); drawBase(); redrawOverlay();
      logHistory('Imported project');
    };
    img.src = data.image;
  } else {
    // no image embedded, just restore overlays
    annotations = data.annotations||[];
    symbols = data.symbols||[];
    segments = data.segments||[];
    netLabels.splice(0, netLabels.length, ...(data.netLabels||[]));
    refreshNetsList?.(); redrawOverlay();
    logHistory('Imported overlays (no base image)');
  }
}
saveProjectBtn?.addEventListener('click', exportProject);
openProjectBtn?.addEventListener('click', ()=> openProjectInput?.click());
openProjectInput?.addEventListener('change', (e)=>{
  const f = e.target.files && e.target.files[0]; if(!f) return;
  importProjectFile(f);
});

// ===== Free continuity mode =====
const contFreeChk = document.getElementById('contFree');
let contFreeMode = false;
contFreeChk?.addEventListener('change', ()=>{ contFreeMode = contFreeChk.checked; if(!contFreeMode){ contSel1 = contSel2 = contResult = null; } redrawOverlay(); });

// Patch continuity to allow any two points when contFreeMode is on
function continuityMouseDown_Free(e){
  if(!contMode || !contFreeMode) return false;
  if(e.button===1) return false;
  const [ix, iy] = screenToImg(e.offsetX, e.offsetY);
  const hit = { symIdx:-1, pinIdx:-1, x: ix, y: iy };
  if(!contSel1){ contSel1 = hit; redrawOverlay(); }
  else if(!contSel2){ contSel2 = hit; testContinuity(contSel1, contSel2); }
  else { contSel1 = hit; contSel2 = null; contResult = null; redrawOverlay(); }
  e.preventDefault(); e.stopPropagation(); return true;
}
view.addEventListener('mousedown', (e)=>{ if(continuityMouseDown_Free(e)) return; }, true);

// Enhance drawContinuityUI to render markers for free points (already uses contSel1/2 so OK)


// Hide 'Tools' headings inside left panel (visual move of controls to top toolbar)
(function(){
  const lp = document.getElementById('leftPanel');
  if(!lp) return;
  const heads = lp.querySelectorAll('h1,h2,h3,h4');
  heads.forEach(h=>{
    if (h.textContent && h.textContent.trim().toLowerCase()==='tools'){
      h.style.display = 'none';
    }
  });
})();

// ===== Boot =====
initTabs(rightTabs);
initTabs(bottomTabs);
loadDock();
initSplitters();
setCanvasSizeToContainer();
logHistory('Ready. Load an image to begin.');

// ==== Cleanup Mode & Line Smoothing ====
let cleanup = { enabled: false, thickness: 0.75, bridge: 0.5,       // blur radius (px) to connect tiny gaps before thresholding
  auto: true,
  ignoreSymbols: false
};
let cleanupMarkers = []; // {x,y,type:'end'|'tee'}

function syncCleanupUI(){
  const en = document.getElementById('cleanupEnabled');
  const th = document.getElementById('cleanupThickness');
  const thv= document.getElementById('cleanupThicknessVal');
  const br = document.getElementById('cleanupBridge');
  const brv= document.getElementById('cleanupBridgeVal');
  const au = document.getElementById('cleanupAuto');
  const ig = document.getElementById('cleanupIgnoreSymbols');
  if(!en||!th||!br||!au||!ig) return;
  en.checked = cleanup.enabled;
  th.value = cleanup.thickness; thv.textContent = (Math.round(cleanup.thickness*100)/100)+' px';
  br.value = cleanup.bridge; brv.textContent = (Math.round(cleanup.bridge*100)/100)+' px';
  au.checked = cleanup.auto;
  ig.checked = cleanup.ignoreSymbols;
}

function initCleanupUI(){
  document.getElementById('cleanupToggle')?.addEventListener('click',()=>{
    cleanup.enabled = !cleanup.enabled; 
    document.getElementById('cleanupEnabled')?.click();
    logHistory('Cleanup '+(cleanup.enabled?'enabled':'disabled'));
    redrawOverlay();
  });
  document.getElementById('cleanupSettingsBtn')?.addEventListener('click',()=>{
    // switch to Cleanup tab if present
    document.getElementById('tabCleanup')?.click();
  });
  document.getElementById('cleanupFindBtn')?.addEventListener('click',()=>{
    findOpensAndTees();
    redrawOverlay();
  });
  const en = document.getElementById('cleanupEnabled');
  const th = document.getElementById('cleanupThickness');
  const thv= document.getElementById('cleanupThicknessVal');
  const br = document.getElementById('cleanupBridge');
  const brv= document.getElementById('cleanupBridgeVal');
  const au = document.getElementById('cleanupAuto');
  const ig = document.getElementById('cleanupIgnoreSymbols');
  const rn = document.getElementById('cleanupRunNow');
  const cm = document.getElementById('cleanupClearMarkers');
  en?.addEventListener('change', (e)=>{ cleanup.enabled = !!en.checked; redrawOverlay(); });
  th?.addEventListener('input', ()=>{ cleanup.thickness = parseFloat(th.value||'1.5'); thv.textContent = (Math.round(cleanup.thickness*100)/100)+' px'; redrawOverlay(); });
  br?.addEventListener('input', ()=>{ cleanup.bridge = parseFloat(br.value||'1.0'); brv.textContent = (Math.round(cleanup.bridge*100)/100)+' px'; redrawOverlay(); });
  au?.addEventListener('change', ()=>{ cleanup.auto = !!au.checked; });
  ig?.addEventListener('change', ()=>{ cleanup.ignoreSymbols = !!ig.checked; });
  rn?.addEventListener('click', ()=>{ runCleanupWithProgress(); });
  cm?.addEventListener('click', ()=>{ cleanupMarkers.length=0; redrawOverlay(); });
  syncCleanupUI();
}
window.addEventListener('load', initCleanupUI);

// Render a filled alpha mask from a binary mask array onto a temporary canvas
const cleanupCanvas = document.createElement('canvas');
const cleanupCtx = cleanupCanvas.getContext('2d', { willReadFrequently:true });
const cleanupStage2 = document.createElement('canvas');
const cleanupCtx2 = cleanupStage2.getContext('2d', { willReadFrequently:true });

function ensureCleanupSize(){
  if(cleanupCanvas.width!==imgW || cleanupCanvas.height!==imgH){
    cleanupCanvas.width = imgW; cleanupCanvas.height = imgH;
    cleanupStage2.width = imgW; cleanupStage2.height = imgH;
  }
}

function drawCleanupFromMask(mask){
  ensureCleanupSize();
  // Stage 1: write alpha from mask
  const id = cleanupCtx.createImageData(imgW, imgH);
  const d = id.data;
  for(let i=0;i<mask.length;i++){
    const a = mask[i] ? 255 : 0;
    const j = i*4;
    d[j]=0; d[j+1]=0; d[j+2]=0; d[j+3]=a;
  }
  cleanupCtx.putImageData(id,0,0);

  // Stage 2: blur to bridge small gaps
  cleanupCtx2.clearRect(0,0,imgW,imgH);
  if(cleanup.bridge>0){
    cleanupCtx2.filter = 'blur('+cleanup.bridge+'px)';
    cleanupCtx2.drawImage(cleanupCanvas,0,0);
    cleanupCtx2.filter = 'none';
  } else {
    cleanupCtx2.drawImage(cleanupCanvas,0,0);
  }

  // Stage 3: threshold back to binary and tint black
  const id2 = cleanupCtx2.getImageData(0,0,imgW,imgH);
  const d2 = id2.data;
  let count=0;
  for(let i=0;i<d2.length;i+=4){
    const a = d2[i+3];
    if(a>64){ // threshold
      d2[i]=0; d2[i+1]=0; d2[i+2]=0; d2[i+3]=255; count++;
    } else {
      d2[i]=0; d2[i+1]=0; d2[i+2]=0; d2[i+3]=0;
    }
  }
  cleanupCtx2.putImageData(id2,0,0);

  // Stage 4: thicken to requested stroke width using a subtle extra blur
  // Treat thickness as 1 + extra, where 1px is the base binary mask.
  const extra = Math.max(0, cleanup.thickness - 1);
  if(extra > 0){
    const sigma = extra * 0.5; // softer growth
    cleanupCtx2.filter = 'blur(' + sigma + 'px)';
    cleanupCtx2.drawImage(cleanupCtx2.canvas,0,0);
    cleanupCtx2.filter = 'none';
    // Re-threshold to keep edges reasonably crisp
    const id3 = cleanupCtx2.getImageData(0,0,imgW,imgH);
    const d3 = id3.data;
    for(let i=0;i<d3.length;i+=4){
      d3[i]=0; d3[i+1]=0; d3[i+2]=0; d3[i+3] = d3[i+3] > 32 ? 255 : 0;
    }
    cleanupCtx2.putImageData(id3,0,0);
  }
  return cleanupStage2;
}

// Scan for endpoints and tees in a binary mask
function scanEndpointsAndTees(mask){
  const W=imgW, H=imgH;
  const get=(x,y)=> (x>=0&&y>=0&&x<W&&y<H) ? mask[y*W+x] : 0;
  const res=[];
  for(let y=1;y<H-1;y+=2){ // stride for speed
    for(let x=1;x<W-1;x+=2){
      if(!get(x,y)) continue;
      let nb=0;
      nb += get(x-1,y-1); nb += get(x,y-1); nb += get(x+1,y-1);
      nb += get(x-1,y  );                  nb += get(x+1,y  );
      nb += get(x-1,y+1); nb += get(x,y+1); nb += get(x+1,y+1);
      if(nb==1) res.push({x,y,type:'end'});
      else if(nb==3) res.push({x,y,type:'tee'});
    }
  }
  return res;
}

function findOpensAndTees(){
  cleanupMarkers.length=0;
  // Merge all visible layer masks for analysis
  const merged = new Uint8Array(imgW*imgH);
  for(const L of layers){ if(!L.visible) continue; const mask=L.mask; for(let i=0;i<mask.length;i++){ merged[i] = merged[i] || mask[i]; } }
  // Optionally smooth a bit before counting neighbors
  const tmp = drawCleanupFromMask(merged);
  // Threshold back into merged
  const id = cleanupCtx2.getImageData(0,0,imgW,imgH).data;
  for(let i=0,px=0;i<id.length;i+=4,px++){ merged[px] = id[i+3]>0 ? 1:0; }
  cleanupMarkers.push(...scanEndpointsAndTees(merged));
  log('[Cleanup] Marked '+cleanupMarkers.length+' endpoints/tees.');
}

// Hook: after tracing, optionally run cleanup (just affects overlay on redraw)
const _orig_traceSegment = typeof traceSegment==='function' ? traceSegment : null;
if(_orig_traceSegment){
  traceSegment = function(ix,iy,opt={}){
    const r = _orig_traceSegment(ix,iy,opt);
    if(cleanup.auto) redrawOverlay();
    return r;
  }
}
const _orig_traceFlood = typeof traceFlood==='function' ? traceFlood : null;
if(_orig_traceFlood){
  traceFlood = function(ix,iy,opt={}){
    const r = _orig_traceFlood(ix,iy,opt);
    if(cleanup.auto) redrawOverlay();
    return r;
  }
}

// Extend redrawOverlay to include cleanup pass + markers (after symbols, then restore labels)
const _orig_redrawOverlay = redrawOverlay;
redrawOverlay = function(){
  _orig_redrawOverlay();
  if(!cleanup.enabled){
    drawCleanupMarkers(octx);
    return;
  }
  octx.save();
  applyViewTransform(octx);
  octx.imageSmoothingEnabled = false;
  for(const L of layers){
    if(!L.visible) continue;
    const src = drawCleanupFromMask(L.mask);
    octx.globalCompositeOperation = cleanup.ignoreSymbols ? 'destination-over' : 'source-over';
    octx.drawImage(src, -imgW/2, -imgH/2);
  }
  octx.restore();
  // Re-draw annotations and net labels to stay on top of cleanup strokes
  drawAnnotationsToCtx(octx,true);
  drawNetLabels(octx,true);
  drawContinuityUI(octx);
  drawCleanupMarkers(octx);
}

function drawCleanupMarkers(ctx){
  if(!cleanupMarkers.length) return;
  ctx.save();
  applyViewTransform(ctx);
  ctx.lineWidth = 1;
  for(const m of cleanupMarkers){
    const [sx,sy] = [m.x - imgW/2, m.y - imgH/2];
    ctx.beginPath();
    ctx.strokeStyle = (m.type==='end') ? '#ffb020' : '#20e0ff';
    ctx.arc(sx, sy, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx-3,sy); ctx.lineTo(sx+3,sy); ctx.moveTo(sx,sy-3); ctx.lineTo(sx,sy+3);
    ctx.stroke();
  }
  ctx.restore();
}

// ===== Text-only cleanup & Retype tool =====
let textCleanup = {
  enabled: true,
  tile: 28,
  C: 12,           // local mean offset
  close: 0.5,      // blur radius
  speckle: 2,      // drop pixels with <=N neighbors
  excludeLines: true
};

let textCleanCanvas = document.createElement('canvas');
let textCleanCtx = textCleanCanvas.getContext('2d', {willReadFrequently:true});

let textPatches = []; // {x,y,w,h}
let retypeMode = false;
let retypeDrag = null;
let retypeRectEl = null;

function ensureTextCanvas(){
  if(textCleanCanvas.width!==imgW || textCleanCanvas.height!==imgH){
    textCleanCanvas.width = imgW; textCleanCanvas.height = imgH;
  }
}

function syncTextUI(){
  const en = document.getElementById('textCleanEnabled');
  const tile = document.getElementById('textTile');
  const tileV= document.getElementById('textTileVal');
  const cc = document.getElementById('textC');
  const ccV= document.getElementById('textCVal');
  const cl = document.getElementById('textClose');
  const clV= document.getElementById('textCloseVal');
  const sp = document.getElementById('textSpeckle');
  const spV= document.getElementById('textSpeckleVal');
  const ex = document.getElementById('textExcludeLines');
  if(!en) return;
  en.checked = textCleanup.enabled;
  tile.value = textCleanup.tile; tileV.textContent = textCleanup.tile+' px';
  cc.value = textCleanup.C; ccV.textContent = textCleanup.C;
  cl.value = textCleanup.close; clV.textContent = textCleanup.close+' px';
  sp.value = textCleanup.speckle; spV.textContent = textCleanup.speckle;
  ex.checked = textCleanup.excludeLines;
}

function initTextUI(){
  document.getElementById('textCleanEnabled')?.addEventListener('change', e=>{ textCleanup.enabled=!!e.target.checked; redrawAll(); });
  document.getElementById('textTile')?.addEventListener('input', e=>{ textCleanup.tile=parseInt(e.target.value,10); document.getElementById('textTileVal').textContent=textCleanup.tile+' px'; buildTextCleanup(); redrawAll(); });
  document.getElementById('textC')?.addEventListener('input', e=>{ textCleanup.C=parseInt(e.target.value,10); document.getElementById('textCVal').textContent=textCleanup.C; buildTextCleanup(); redrawAll(); });
  document.getElementById('textClose')?.addEventListener('input', e=>{ textCleanup.close=parseFloat(e.target.value); document.getElementById('textCloseVal').textContent=textCleanup.close+' px'; buildTextCleanup(); redrawAll(); });
  document.getElementById('textSpeckle')?.addEventListener('input', e=>{ textCleanup.speckle=parseInt(e.target.value,10); document.getElementById('textSpeckleVal').textContent=textCleanup.speckle; buildTextCleanup(); redrawAll(); });
  document.getElementById('textExcludeLines')?.addEventListener('change', e=>{ textCleanup.excludeLines=!!e.target.checked; buildTextCleanup(); redrawAll(); });
document.getElementById('textBuildBtn')?.addEventListener('click', ()=>{ runTextCleanupWithProgress(); });
  document.getElementById('textClearBtn')?.addEventListener('click', ()=>{ textCleanCtx.clearRect(0,0,imgW,imgH); redrawAll(); });
  document.getElementById('retypeToggle2')?.addEventListener('click', ()=>{ toggleRetype(); });
  document.getElementById('clearRetypePatches')?.addEventListener('click', ()=>{ textPatches.length=0; redrawAll(); });
  document.getElementById('retypeToggle')?.addEventListener('click', ()=>{ toggleRetype(); });
  window.addEventListener('keydown',(e)=>{
    if(e.key==='r' || e.key==='R'){ toggleRetype(); e.preventDefault(); }
  });
  syncTextUI();
}
window.addEventListener('load', initTextUI);

function toggleRetype(){
  retypeMode = !retypeMode;
  if(retypeMode){
    log('[Retype] Box a text region to replace. Type to add label after release.');
    if(!retypeRectEl){
      retypeRectEl = document.createElement('div');
      retypeRectEl.className = 'retype-rect';
      document.querySelector('.canvasWrap')?.appendChild(retypeRectEl);
      retypeRectEl.style.display = 'none';
    }
  }else{
    if(retypeRectEl) retypeRectEl.style.display = 'none';
  }
}

// Build a text-only cleaned overlay
function buildTextCleanup(){
  if(!rawImageData || imgW===0 || imgH===0) return;
  ensureTextCanvas();
  // Step 1: tile-local threshold
  const tile = Math.max(8, textCleanup.tile|0);
  const C = textCleanup.C|0;
  const d = rawImageData.data;
  const W = imgW, H = imgH;
  const bin = new Uint8Array(W*H);
  for(let ty=0; ty<H; ty+=tile){
    for(let tx=0; tx<W; tx+=tile){
      const maxY = Math.min(H, ty+tile), maxX = Math.min(W, tx+tile);
      let sum=0, cnt=0;
      for(let y=ty; y<maxY; y+=1){
        let idx = (y*W + tx)*4;
        for(let x=tx; x<maxX; x+=1, idx+=4){
          const r=d[idx], g=d[idx+1], b=d[idx+2];
          const Y = (0.2126*r + 0.7152*g + 0.0722*b);
          sum += Y; cnt++;
        }
      }
      const mean = sum / (cnt||1);
      const thr = Math.max(0, Math.min(255, mean - C));
      for(let y=ty; y<maxY; y+=1){
        let idx = (y*W + tx)*4;
        for(let x=tx; x<maxX; x+=1, idx+=4){
          const r=d[idx], g=d[idx+1], b=d[idx+2];
          const Y = (0.2126*r + 0.7152*g + 0.0722*b);
          const on = (Y < thr) ? 1 : 0;
          bin[y*W + x] = on;
        }
      }
    }
  }
  // Step 2: despeckle by neighbor count
  if(textCleanup.speckle>0){
    const out = new Uint8Array(W*H);
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const i=y*W+x;
        if(!bin[i]) continue;
        let nb=0;
        nb += bin[i-1]; nb += bin[i+1];
        nb += bin[i-W]; nb += bin[i+W];
        nb += bin[i-W-1]; nb += bin[i-W+1]; nb += bin[i+W-1]; nb += bin[i+W+1];
        if(nb > textCleanup.speckle) out[i]=1; else out[i]=0;
      }
    }
    bin.set(out);
  }
  // Step 3: exclude traced lines (dilate by 1px)
  if(textCleanup.excludeLines){
    const line = new Uint8Array(W*H);
    for(const L of layers){
      if(!L.visible) continue;
      const m = L.mask;
      for(let i=0;i<m.length;i++){ if(m[i]) line[i]=1; }
    }
    // one-pass dilation
    const dil = new Uint8Array(W*H);
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const i=y*W+x;
        if(line[i]||line[i-1]||line[i+1]||line[i-W]||line[i+W]||line[i-W-1]||line[i-W+1]||line[i+W-1]||line[i+W+1]) dil[i]=1;
      }
    }
    for(let i=0;i<bin.length;i++){ if(dil[i]) bin[i]=0; }
  }
  // Step 4: draw to canvas alpha, blur (close), threshold, and paint with white underlay + black text
  const id = textCleanCtx.createImageData(W,H);
  const dd = id.data;
  for(let i=0;i<bin.length;i++){
    const a = bin[i] ? 255 : 0;
    const j = i*4;
    dd[j]=0; dd[j+1]=0; dd[j+2]=0; dd[j+3]=a;
  }
  textCleanCtx.putImageData(id,0,0);
  // Close (blur) then threshold again
  if(textCleanup.close>0){
    textCleanCtx.filter = 'blur('+textCleanup.close+'px)';
    textCleanCtx.drawImage(textCleanCtx.canvas,0,0);
    textCleanCtx.filter = 'none';
  }
  const id2 = textCleanCtx.getImageData(0,0,W,H);
  const d2 = id2.data;
  for(let i=0;i<d2.length;i+=4){
    const a = d2[i+3];
    if(a>64){
      // draw white underlay (expand 0.5px via second blur-like pass)
      d2[i]=0; d2[i+1]=0; d2[i+2]=0; d2[i+3]=255; // black glyph
    }else{
      d2[i]=0; d2[i+1]=0; d2[i+2]=0; d2[i+3]=0;   // transparent
    }
  }
  textCleanCtx.putImageData(id2,0,0);
  // Create the white underlay by drawing an expanded alpha to a temp and compositing
  const under = document.createElement('canvas');
  under.width=W; under.height=H;
  const uctx = under.getContext('2d', {willReadFrequently:true});
  uctx.putImageData(id,0,0); // original binary alpha
  uctx.filter = 'blur(0.6px)'; uctx.drawImage(under,0,0); uctx.filter='none';
  const idu = uctx.getImageData(0,0,W,H);
  const du = idu.data;
  for(let i=0;i<du.length;i+=4){
    du[i]=255; du[i+1]=255; du[i+2]=255; du[i+3] = du[i+3]>24 ? 255:0;
  }
  uctx.putImageData(idu,0,0);
  // Bake final: white underlay then black glyphs (onto textCleanCtx)
  textCleanCtx.clearRect(0,0,W,H);
  textCleanCtx.drawImage(under,0,0);
  textCleanCtx.drawImage((function(){const c=document.createElement('canvas'); c.width=W; c.height=H; c.getContext('2d').putImageData(id2,0,0); return c;})(),0,0);
}

// Retype interactions on the view canvas
view.addEventListener('mousedown',(e)=>{
  if(!retypeMode) return;
  const [ix,iy]=screenToImg(e.offsetX,e.offsetY);
  retypeDrag = {x0:ix, y0:iy, x1:ix, y1:iy};
  if(retypeRectEl){ retypeRectEl.style.display='block'; }
});
view.addEventListener('mousemove',(e)=>{
  if(!retypeMode || !retypeDrag) return;
  const [ix,iy]=screenToImg(e.offsetX,e.offsetY);
  retypeDrag.x1=ix; retypeDrag.y1=iy;
  // draw selection rect in screen coords
  const [sx0,sy0]=imgToScreen(retypeDrag.x0,retypeDrag.y0);
  const [sx1,sy1]=imgToScreen(retypeDrag.x1,retypeDrag.y1);
  const x=Math.min(sx0,sx1), y=Math.min(sy0,sy1);
  const w=Math.abs(sx1-sx0), h=Math.abs(sy1-sy0);
  Object.assign(retypeRectEl.style,{left:x+'px',top:y+'px',width:w+'px',height:h+'px'});
});
window.addEventListener('mouseup',()=>{
  if(!retypeMode || !retypeDrag) return;
  const x=Math.min(retypeDrag.x0,retypeDrag.x1)|0;
  const y=Math.min(retypeDrag.y0,retypeDrag.y1)|0;
  const w=Math.max(6, Math.abs(retypeDrag.x1-retypeDrag.x0)|0);
  const h=Math.max(6, Math.abs(retypeDrag.y1-retypeDrag.y0)|0);
  retypeDrag=null;
  if(retypeRectEl) retypeRectEl.style.display='none';
  // Store white patch
  textPatches.push({x,y,w,h});
  logHistory('Retype patch added '+w+'×'+h+' at ('+x+','+y+')');
  // Open editor centered
  const [sx,sy] = imgToScreen(x + w/2, y + h/2);
  openEditor(sx, sy, -1);
});

// Patch drawBase to apply text cleanup and retype white patches
const _orig_drawBase = drawBase;
drawBase = function(){
  _orig_drawBase();
  const ctx=vctx;
  ctx.save();
  applyViewTransform(ctx);
  // 1) Draw retype patches (white)
  if(textPatches.length){
    ctx.fillStyle='#fff';
    for(const p of textPatches){
      ctx.fillRect(p.x - imgW/2, p.y - imgH/2, p.w, p.h);
    }
  }
  // 2) Draw cleaned text overlay
  if(textCleanup.enabled){
    ensureTextCanvas();
    ctx.globalCompositeOperation='source-over';
    ctx.drawImage(textCleanCanvas, -imgW/2, -imgH/2);
  }
  ctx.restore();
};

// Rebuild text cleanup whenever a new image is loaded
const _orig_onImageLoaded = typeof onImageLoaded==='function' ? onImageLoaded : null;
if(_orig_onImageLoaded){
  onImageLoaded = function(...args){
    const r = _orig_onImageLoaded.apply(this,args);
    buildTextCleanup();
    return r;
  }
}

// === Progress overlay helpers ===
const _pm = { el: null, fill: null, title: null, text: null };
function ensureProgressModal(){
  if(_pm.el) return;
  _pm.el = document.getElementById('progressModal');
  _pm.fill= document.getElementById('progressFill');
  _pm.title=document.getElementById('progressTitle');
  _pm.text =document.getElementById('progressText');
}
function showProgress(title, msg){
  ensureProgressModal();
  _pm.title.textContent = title||'Working…';
  _pm.text.textContent  = msg||'';
  _pm.fill.style.width = '0%';
  _pm.el.style.display='flex';
  requestAnimationFrame(()=>{});
}
function updateProgress(pct, msg){
  ensureProgressModal();
  if(typeof pct==='number') _pm.fill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  if(msg) _pm.text.textContent = msg;
}
function hideProgress(){
  if(!_pm.el) return;
  _pm.el.style.display='none';
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function runCleanupWithProgress(){
  showProgress('Cleanup', 'Preparing…');
  await sleep(10); // let UI paint
  try{
    updateProgress(10, 'Refreshing overlay…');
    await new Promise(r=>requestAnimationFrame(r));
    redrawOverlay();
    updateProgress(100, 'Done');
  } catch(err){
    console.error('Cleanup error:', err);
    logHistory('[error] Cleanup failed: ' + (err?.message||err));
  } finally{
    await sleep(60);
    hideProgress();
  }
}

async function runTextCleanupWithProgress(){
  showProgress('Text cleanup', 'Analyzing…');
  await sleep(10);
  try{
    updateProgress(35, 'Threshold & binarize…');
    await new Promise(r=>requestAnimationFrame(r));
    buildTextCleanup();
    updateProgress(85, 'Rendering…');
    await new Promise(r=>requestAnimationFrame(r));
    redrawAll?.();
    updateProgress(100, 'Done');
  } catch(err){
    console.error('Text cleanup error:', err);
    logHistory('[error] Text cleanup failed: ' + (err?.message||err));
  } finally{
    await sleep(60);
    hideProgress();
  }
}

// === Preset chip wiring ===
window.addEventListener('load', ()=>{
  const th = document.getElementById('cleanupThickness');
  const thv= document.getElementById('cleanupThicknessVal');
  const br = document.getElementById('cleanupBridge');
  const brv= document.getElementById('cleanupBridgeVal');
  const apply = ()=>{
    if(th) th.value = ''+cleanup.thickness;
    if(br) br.value = ''+cleanup.bridge;
    if(thv) thv.textContent = (Math.round(cleanup.thickness*100)/100)+' px';
    if(brv) brv.textContent = (Math.round(cleanup.bridge*100)/100)+' px';
    redrawOverlay?.();
  };
  document.getElementById('cleanupPresetFine')?.addEventListener('click', ()=>{ cleanup.thickness=0.75; cleanup.bridge=0.5; apply(); });
  document.getElementById('cleanupPresetNormal')?.addEventListener('click', ()=>{ cleanup.thickness=1.5; cleanup.bridge=1.0; apply(); });
  document.getElementById('cleanupPresetBold')?.addEventListener('click', ()=>{ cleanup.thickness=2.5; cleanup.bridge=1.5; apply(); });
});


// === Toolbar Icons ===
function _svg(s){ return s.trim(); }
const ICONS = {
  toggleLeft: _svg(`<svg viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="16" rx="2"/><line x1="8" y1="4" x2="8" y2="20"/></svg>`),
  toggleRight: _svg(`<svg viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="16" rx="2"/><line x1="16" y1="4" x2="16" y2="20"/></svg>`),
  toggleBottom: _svg(`<svg viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="16" rx="2"/><line x1="3" y1="16" x2="21" y2="16"/></svg>`),

  topPan: _svg(`<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="1"/><path d="M12 3v4M12 17v4M3 12h4M17 12h4M5 5l2.8 2.8M16.2 16.2L19 19M19 5l-2.8 2.8M5 19l2.8-2.8"/></svg>`),
  topHighlight: _svg(`<svg viewBox="0 0 24 24"><path d="M3 21l3-3h4l7-7a2 2 0 0 0 0-3l-1-1a2 2 0 0 0-3 0l-7 7v4l-3 3z"/><path d="M14 7l3 3"/></svg>`),
  topText: _svg(`<svg viewBox="0 0 24 24"><path d="M4 7h16M9 7v10M15 7v10"/></svg>`),
  topEraser: _svg(`<svg viewBox="0 0 24 24"><path d="M16 3l5 5-9 9H7L2 12l9-9z"/><path d="M6 17h16"/></svg>`),
  topLine: _svg(`<svg viewBox="0 0 24 24"><circle cx="6" cy="18" r="2"/><circle cx="18" cy="6" r="2"/><path d="M8 16L16 8"/></svg>`),
  topNet: _svg(`<svg viewBox="0 0 24 24"><circle cx="6" cy="12" r="2"/><circle cx="18" cy="6" r="2"/><circle cx="18" cy="18" r="2"/><path d="M8 12h8M18 8v8"/></svg>`),
  topCont: _svg(`<svg viewBox="0 0 24 24"><path d="M3 12h5c2 0 2 4 4 4s2-4 4-4h5"/><path d="M14 12l2 2l3-3"/></svg>`),

  cleanupToggle: _svg(`<svg viewBox="0 0 24 24"><path d="M3 17l7-7m2-2l3-3 4 4-3 3"/><path d="M3 17h7l4-4"/></svg>`),
  cleanupFindBtn: _svg(`<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="5"/><path d="M14 14l6 6"/><circle cx="18" cy="6" r="2"/><path d="M12 8l4-2"/></svg>`),
  cleanupSettingsBtn: _svg(`<svg viewBox="0 0 24 24"><path d="M12 15a3 3 0 1 0 0-6a3 3 0 0 0 0 6z"/><path d="M19.4 15a1.7 1.7 0 0 0 .3 1.9l.1.1-1.7 3a1.8 1.8 0 0 1-2.1.8 6.6 6.6 0 0 0-1.7-.4 6.8 6.8 0 0 0-1.3 0 6.6 6.6 0 0 0-1.7.4 1.8 1.8 0 0 1-2.1-.8l-1.7-3 .1-.1a1.7 1.7 0 0 0 .3-1.9 6.6 6.6 0 0 1 0-1.3 1.7 1.7 0 0 0-.3-1.9l-.1-.1 1.7-3a1.8 1.8 0 0 1 2.1-.8 6.6 6.6 0 0 0 1.7.4 6.8 6.8 0 0 0 1.3 0 6.6 6.6 0 0 0 1.7-.4 1.8 1.8 0 0 1 2.1.8l1.7 3-.1.1a1.7 1.7 0 0 0-.3 1.9 6.6 6.6 0 0 1 0 1.3z"/></svg>`),

  retypeToggle: _svg(`<svg viewBox="0 0 24 24"><path d="M4 6h16M10 6v12M14 6v12"/></svg>`),

  fit: _svg(`<svg viewBox="0 0 24 24"><path d="M3 9V3h6M21 9V3h-6M3 15v6h6M21 15v6h-6"/></svg>`),
  clear: _svg(`<svg viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M8 6l1-2h6l1 2"/><rect x="5" y="6" width="14" height="14" rx="2"/></svg>`),
  download: _svg(`<svg viewBox="0 0 24 24"><path d="M12 3v12"/><path d="M8 11l4 4 4-4"/><path d="M3 21h18"/></svg>`),
  saveProject: _svg(`<svg viewBox="0 0 24 24"><path d="M5 3h11l5 5v13H5z"/><path d="M9 3v6h6"/><rect x="8" y="13" width="8" height="6" rx="1"/></svg>`),
  openProjectBtn: _svg(`<svg viewBox="0 0 24 24"><path d="M3 7h6l2 2h10v10H3z"/></svg>`),
  undoBtn: _svg(`<svg viewBox="0 0 24 24"><path d="M9 7l-5 5 5 5"/><path d="M20 12a7 7 0 0 0-11-5"/></svg>`),
  redoBtn: _svg(`<svg viewBox="0 0 24 24"><path d="M15 7l5 5-5 5"/><path d="M4 12a7 7 0 0 1 11-5"/></svg>`)
};

function addToolbarIcons(){
  for(const [id,svg] of Object.entries(ICONS)){
    const btn = document.getElementById(id);
    if(!btn) continue;
    if(btn.querySelector('.ico')) continue; // already has icon
    const labelHTML = btn.innerHTML.trim();
    btn.innerHTML = `<span class="ico">${svg}</span><span class="lbl">${labelHTML}</span>`;
    if(!btn.getAttribute('aria-label')){
      const tmp = document.createElement('div'); tmp.innerHTML = labelHTML;
      btn.setAttribute('aria-label', (tmp.textContent||'').trim());
    }
  }
}
window.addEventListener('load', addToolbarIcons);


// --- Keep dock sized to dynamic header height ---
function _updateHeaderHeight(){
  const h = document.querySelector('header');
  if(!h) return;
  const px = h.offsetHeight + 'px';
  document.documentElement.style.setProperty('--headerH', px);
}
window.addEventListener('load', _updateHeaderHeight);
window.addEventListener('resize', _updateHeaderHeight);
// If we add icons or wrap rows after load, adjust once more
setTimeout(_updateHeaderHeight, 50);


// === Panel chevrons & reveals ===
(function(){
  const dock = document.getElementById('dock');
  const toggleLeftBtn = document.getElementById('toggleLeft');
  const toggleRightBtn = document.getElementById('toggleRight');
  const toggleBottomBtn = document.getElementById('toggleBottom');
  // Hide the old panel buttons from header
  document.querySelector('.toolbar-left')?.setAttribute('style','display:none');

  function hideLeft(){ if(!dock.classList.contains('hide-left')){ dock.classList.add('hide-left'); toggleLeftBtn?.classList.remove('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }
  function showLeft(){ if(dock.classList.contains('hide-left')){ dock.classList.remove('hide-left'); toggleLeftBtn?.classList.add('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }
  function hideRight(){ if(!dock.classList.contains('hide-right')){ dock.classList.add('hide-right'); toggleRightBtn?.classList.remove('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }
  function showRight(){ if(dock.classList.contains('hide-right')){ dock.classList.remove('hide-right'); toggleRightBtn?.classList.add('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }
  function hideBottom(){ if(!dock.classList.contains('hide-bottom')){ dock.classList.add('hide-bottom'); toggleBottomBtn?.classList.remove('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }
  function showBottom(){ if(dock.classList.contains('hide-bottom')){ dock.classList.remove('hide-bottom'); toggleBottomBtn?.classList.add('active'); saveDock?.(); setCanvasSizeToContainer?.(); } }

  document.getElementById('chevLeft')?.addEventListener('click', hideLeft);
  document.getElementById('chevRight')?.addEventListener('click', hideRight);
  document.getElementById('chevBottom')?.addEventListener('click', hideBottom);
  document.getElementById('chevBottomSplit')?.addEventListener('click', hideBottom);
  document.getElementById('revealLeft')?.addEventListener('click', showLeft);
  document.getElementById('revealRight')?.addEventListener('click', showRight);
  document.getElementById('revealBottom')?.addEventListener('click', showBottom);
})();


// --- Sync bottom chevron titles/rotation with state ---
(function(){
  function syncChevrons(){
    const dock = document.getElementById('dock');
    const hidden = dock?.classList.contains('hide-bottom');
    const tHide = 'Hide bottom panel';
    const tShow = 'Show bottom panel';
    const b1 = document.getElementById('chevBottomSplit');
    const b2 = document.getElementById('chevBottom');
    if(b1) b1.title = b1.ariaLabel = hidden ? tShow : tHide;
    if(b2) b2.title = b2.ariaLabel = hidden ? tShow : tHide;
  }
  window.addEventListener('load', syncChevrons);
  // Hook into existing buttons
  const btns = ['revealBottom','chevBottomSplit','chevBottom'];
  btns.forEach(id=> document.getElementById(id)?.addEventListener('click', ()=> setTimeout(syncChevrons, 10)));
})();



// ==== Net label + animated chevrons overlay (injected safe) ====
(function(){
  const ARROW_SPACING = 80;
  const ARROW_SIZE = 10;
  const LABEL_OFFSET = 14;
  const ANIM_SPEED_PX_S = 120;

  let _arrowAnimStart = performance.now();

  window.drawNetLabelAndArrows = function(path, name, opts = {}) {
    const ctx = opts.ctx || window.octx || window.overlayCtx || window.ctx || null;
    if (!ctx || !path || !path.length) return;
    const selected = !!opts.selected;
    const color = opts.color || '#6bb2ff';

    // Label at the start
    const p0 = path[0];
    const p1 = path[1] || path[0];
    const ang = Math.atan2(p1.y - p0.y, p1.x - p0.x);
    const lbOff = LABEL_OFFSET;
    const lx = p0.x + Math.cos(ang) * 8 - Math.sin(ang) * lbOff;
    const ly = p0.y + Math.sin(ang) * 8 + Math.cos(ang) * lbOff;
    drawPillLabel(ctx, lx, ly, name || 'NET');

    // Marching chevrons along path
    const now = performance.now();
    const dt = (now - _arrowAnimStart) / 1000;
    const phasePx = selected ? (dt * ANIM_SPEED_PX_S) % ARROW_SPACING : 0;

    let carry = ARROW_SPACING - phasePx;
    for (let i = 1; i < path.length; i++) {
      const a = path[i - 1], b = path[i];
      const dx = b.x - a.x, dy = b.y - a.y;
      const seg = Math.hypot(dx, dy);
      if (seg < 1) continue;
      const theta = Math.atan2(dy, dx);

      let d = carry;
      while (d <= seg) {
        const t = d / seg;
        const x = a.x + dx * t, y = a.y + dy * t;
        drawChevron(ctx, x, y, theta, ARROW_SIZE, color);
        d += ARROW_SPACING;
      }
      carry = d - seg;
    }
  };

  function drawPillLabel(ctx, x, y, text) {
    ctx.save();
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial';
    const padX = 8;
    const metrics = ctx.measureText(text);
    const w = Math.max(24, metrics.width + padX * 2);
    const h = 18;
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    roundRect(ctx, -w/2, -h/2, w, h, 9, true, true);
    ctx.fillStyle = '#e8eef7';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, -w/2 + padX, 0);
    ctx.restore();
  }

  function drawChevron(ctx, x, y, angle, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(-size*0.6, -size*0.4);
    ctx.lineTo(0, 0);
    ctx.lineTo(-size*0.6,  size*0.4);
    ctx.stroke();
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
})();
// ==== end injection ====

</script>

    <div id="paneCleanup" class="tabpane" role="tabpanel" aria-labelledby="tabCleanup" hidden>
      <div class="group">
        <label><input type="checkbox" id="cleanupEnabled"> Enable cleanup overlay</label>
      </div>
      <div class="group">
        <label>Stroke thickness <input type="range" id="cleanupThickness" min="0.5" max="12" step="0.25" value="1.5"></label>
        <span id="cleanupThicknessVal">3 px</span>
      </div>
      <div class="group">
        <label>Bridge gaps (blur px) <input type="range" id="cleanupBridge" min="0" max="6" step="0.25" value="1"></label>
        <span id="cleanupBridgeVal">2 px</span>
      </div>
      <div class="group">
        <label><input type="checkbox" id="cleanupAuto"> Auto after trace</label>
      </div>
      <div class="group">
        <label><input type="checkbox" id="cleanupIgnoreSymbols"> Ignore symbols while cleaning</label>
      </div>
      <div class="row">
        <button id="cleanupRunNow">Run cleanup now</button>
        <button id="cleanupClearMarkers" title="Clear markers from last Find Opens/Tees">Clear markers</button>
      </div>
      <p class="muted">Cleanup draws a constant-thickness black stroke along traced masks, bridging tiny gaps and painting over symbols/text.</p>
    </div>
    
<div id="progressModal" role="dialog" aria-modal="true">
  <div id="progressCard">
    <h3 id="progressTitle">Working…</h3>
    <div class="progressBar"><div id="progressFill"></div></div>
    <div id="progressText">Please wait</div>
    <div class="row" style="justify-content:flex-end;gap:8px"><button id="progressCancel" style="display:none">Cancel</button></div>
  </div>
</div>

<script>
  (function(){
    const logEl = document.getElementById('testLog') || document.getElementById('log') || null;
    window.onerror = function(msg, src, line, col, err){
      if(!logEl) return;
      const p = document.createElement('div');
      p.textContent = `[JS Error] ${msg} @ ${line}:${col}`;
      p.style.color = '#ff6b6b';
      logEl.prepend(p);
    };
  })();


// ==== Net label + animated chevrons overlay (anim-driving) ====
(function(){
  const ARROW_SPACING = 80;
  const ARROW_SIZE = 10;
  const LABEL_OFFSET = 14;
  const ANIM_SPEED_PX_S = 120;

  let _arrowAnimStart = performance.now();
  window.__arrowAnimActive = window.__arrowAnimActive || false;

  function ensureArrowAnimLoop(){
    if (window.__arrowAnimLoopRunning) return;
    window.__arrowAnimLoopRunning = true;
    function tick(){
      if (window.__arrowAnimActive && typeof window.redrawOverlay === 'function') {
        try { window.redrawOverlay(); } catch(e){ /* no-op */ }
        requestAnimationFrame(tick);
      } else {
        // Pause the loop until re-activated
        window.__arrowAnimLoopRunning = false;
      }
    }
    requestAnimationFrame(tick);
  }

  // Expose to drawNetLabels so it can toggle animation state
  window.__setArrowAnimActive = function(active){
    window.__arrowAnimActive = !!active;
    if (active) ensureArrowAnimLoop();
  };

  window.drawNetLabelAndArrows = function(path, name, opts = {}) {
    const ctx = opts.ctx || window.octx || window.overlayCtx || window.ctx || null;
    if (!ctx || !path || !path.length) return;
    const selected = !!opts.selected;
    const color = opts.color || '#6bb2ff';

    // Label at the start
    const p0 = path[0];
    const p1 = path[1] || path[0];
    const ang = Math.atan2(p1.y - p0.y, p1.x - p0.x);
    const lbOff = LABEL_OFFSET;
    const lx = p0.x + Math.cos(ang) * 8 - Math.sin(ang) * lbOff;
    const ly = p0.y + Math.sin(ang) * 8 + Math.cos(ang) * lbOff;
    drawPillLabel(ctx, lx, ly, name || 'NET');

    // Marching chevrons along path
    const now = performance.now();
    const dt = (now - _arrowAnimStart) / 1000;
    const phasePx = selected ? (dt * ANIM_SPEED_PX_S) % ARROW_SPACING : 0;

    let carry = ARROW_SPACING - phasePx;
    for (let i = 1; i < path.length; i++) {
      const a = path[i - 1], b = path[i];
      const dx = b.x - a.x, dy = b.y - a.y;
      const seg = Math.hypot(dx, dy);
      if (seg < 1) continue;
      const theta = Math.atan2(dy, dx);

      let d = carry;
      while (d <= seg) {
        const t = d / seg;
        const x = a.x + dx * t, y = a.y + dy * t;
        drawChevron(ctx, x, y, theta, ARROW_SIZE, color);
        d += ARROW_SPACING;
      }
      carry = d - seg;
    }
  };

  function drawPillLabel(ctx, x, y, text) {
    ctx.save();
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial';
    const padX = 8;
    const metrics = ctx.measureText(text);
    const w = Math.max(24, metrics.width + padX * 2);
    const h = 18;
    ctx.translate(x, y);
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    roundRect(ctx, -w/2, -h/2, w, h, 9, true, true);
    ctx.fillStyle = '#e8eef7';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, -w/2 + padX, 0);
    ctx.restore();
  }

  function drawChevron(ctx, x, y, angle, size, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.lineWidth = 2;
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.moveTo(-size*0.6, -size*0.4);
    ctx.lineTo(0, 0);
    ctx.lineTo(-size*0.6,  size*0.4);
    ctx.stroke();
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
})();
// ==== end injection ====



// ==== Chevron placement using underlying ink (BFS + structure tensor) ====
(function(){
  // Returns {pts:[{x,y,theta},...], key}
  window.computeChevronPositionsForNet = function(seed, spacingScreenPx){
    try {
      const threshold = +thresh.value;
      const spacingImg = Math.max(8, Math.floor(spacingScreenPx / Math.max(0.001, window.viewScale||1)));
      const key = `${seed.x},${seed.y}|thr=${threshold}|sp=${spacingImg}|w=${imgW}|h=${imgH}`;

      // BFS collect connected ink + geodesic distance from seed
      const seen = new Uint8Array(imgW*imgH);
      const dist = new Float32Array(imgW*imgH);
      const q = [];
      const sIdx = (seed.y|0)*imgW + (seed.x|0);
      if (!isInk(seed.x|0, seed.y|0, threshold)) return { pts: [], key };
      seen[sIdx] = 1; dist[sIdx] = 0; q.push(sIdx);

      const dirs = [
        [-1, 0, 1], [1, 0, 1], [0, -1, 1], [0, 1, 1],
        [-1,-1, Math.SQRT2], [1,-1, Math.SQRT2], [-1,1, Math.SQRT2], [1,1, Math.SQRT2]
      ];
      const MAX = Math.min(imgW*imgH, (+limit.value||200)*2000);

      let qi = 0, steps = 0;
      while (qi < q.length && steps < MAX) {
        const cur = q[qi++];
        const cx = cur % imgW, cy = (cur/imgW)|0;
        const base = dist[cur];
        for (let k=0;k<8;k++){
          const dx=dirs[k][0], dy=dirs[k][1], cost=dirs[k][2];
          const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue;
          const nIdx = ny*imgW + nx;
          if (seen[nIdx]) continue;
          if (!isInk(nx, ny, threshold)) continue;
          seen[nIdx]=1;
          dist[nIdx]=base+cost;
          q.push(nIdx);
        }
        steps++;
      }

      // Pick points at roughly equal geodesic spacing
      const pts = [];
      if (!q.length) return { pts, key };
      const maxD = dist[q[q.length-1]] || 0;
      const stride = spacingImg;
      if (stride <= 0) return { pts, key };

      // Map to buckets by rounding distance/stride
      const used = new Set();
      for (let i=0;i<q.length;i++){
        const idx = q[i];
        const d = dist[idx];
        const bucket = Math.round(d / stride);
        if (used.has(bucket)) continue;
        used.add(bucket);
        const x = idx % imgW, y = (idx/imgW)|0;
        const theta = estimateTangentAngle(x, y, threshold);
        pts.push({ x, y, theta });
      }
      return { pts, key };
    } catch(e){
      console.warn('computeChevronPositionsForNet error', e);
      return { pts: [], key: 'err' };
    }
  };

  // Estimate local tangent using structure tensor of ink around (x,y)
  function estimateTangentAngle(x, y, threshold){
    const R = 2; // window radius
    let Sxx=0, Syy=0, Sxy=0;
    for (let dy=-R; dy<=R; dy++){
      for (let dx=-R; dx<=R; dx++){
        if (dx===0 && dy===0) continue;
        const nx=x+dx, ny=y+dy; if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue;
        if (isInk(nx,ny,threshold)){
          Sxx += dx*dx; Syy += dy*dy; Sxy += dx*dy;
        }
      }
    }
    // principal direction (eigenvector of largest eigenvalue)
    const Txx=Sxx, Tyy=Syy, Txy=Sxy;
    // Avoid degenerate: default to 0 rad
    let angle = 0;
    const tr = Txx + Tyy;
    const det = Txx*Tyy - Txy*Txy;
    const disc = Math.max(0, tr*tr/4 - det);
    const lambda1 = tr/2 + Math.sqrt(disc); // largest eigenvalue
    // eigenvector for lambda1
    let vx = (lambda1 - Tyy);
    let vy = Txy;
    if (Math.hypot(vx,vy) < 1e-3){
      vx = Txy; vy = (lambda1 - Txx);
    }
    if (Math.hypot(vx,vy) >= 1e-3){
      angle = Math.atan2(vy, vx);
    }
    return angle;
  }
})();
// ==== end helpers ====

</script>

<script>
// Global chevron drawer for overlays
(function(){
  window.drawChevron = function(ctx, x, y, angle, size, color){
    try {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle || 0);
      ctx.lineWidth = 2;
      ctx.strokeStyle = color || '#6bb2ff';
      ctx.beginPath();
      ctx.moveTo(-size*0.6, -size*0.4);
      ctx.lineTo(0, 0);
      ctx.lineTo(-size*0.6,  size*0.4);
      ctx.stroke();
      ctx.restore();
    } catch(e){ /* noop */ }
  };
})();

// --- Patch: auto-apply arrows from overlay highlight ---
(function(){
  const $ = s=>document.querySelector(s);
  function readOpts(){
    const speedMap=[0,0.25,0.5,0.9,1.3];
    const getI = (id,def)=>{ const el=$(id); return el? parseInt(el.value||def,10):def; };
    const getB = (id)=>!!($(id)&&$(id).checked);
    const val  = (id,def)=> $(id)?.value || def;
    return {
      step:getI('#rngChevronSpace',52), size:getI('#rngChevronSize',18),
      marching:getB('#chkChevronMarch'), speed:speedMap[getI('#rngChevronSpeed',2)]||0.9,
      labelShow:getB('#chkLabelShow'), labelSize:getI('#rngLabelSize',14),
      arrowColor:val('#colArrow','#6bb2ff'), labelBg:val('#colLabelBg','#141820'), labelFg:val('#colLabelFg','#e8eef7'),
      arrowStyle:val('#selArrowStyle','triangle'), startOffset:getI('#rngStartOffset',12), autoDensity:getB('#chkAutoDensity')
    };
  }
  function ensureReady(){ return !!window.__arrows_setPath && document.getElementById('arrowsCanvas'); }

  function fromOverlay(){
    const ov = document.getElementById('overlay');
    if(!ov) return null;
    const ctx = ov.getContext('2d');
    const w=ov.width, h=ov.height;
    if(w*h===0) return null;
    const img = ctx.getImageData(0,0,w,h);
    const a = img.data;
    const pts = [];
    const rowStep = Math.max(2, Math.floor(Math.max(w,h)/600));
    const redish = (i)=>{ const r=a[i], g=a[i+1], b=a[i+2], al=a[i+3]; return al>10 && r > 150 && r > g+20; };
    for(let y=0; y<h; y+=rowStep){
      let bestLen=0, bestMid=-1, runLen=0, runStart=-1;
      for(let x=0; x<w; x++){
        const i=(y*w+x)*4;
        if(redish(i)){
          if(runLen===0) runStart=x;
          runLen++;
        }else if(runLen){
          if(runLen>bestLen){ bestLen=runLen; bestMid = Math.round((runStart + (x-1))/2); }
          runLen=0; runStart=-1;
        }
      }
      if(runLen && runLen>bestLen){ bestLen=runLen; bestMid = Math.round((runStart + (w-1))/2); }
      if(bestLen>8 && bestMid>=0){ pts.push({x:bestMid, y}); }
    }
    if(pts.length<2) return null;
    pts.sort((p,q)=> p.y===q.y ? p.x-q.x : p.y-q.y);
    const thinned=[pts[0]];
    const step = 12;
    for(let i=1;i<pts.length;i++){
      const a=thinned[thinned.length-1], b=pts[i];
      const d=Math.hypot(b.x-a.x, b.y-a.y);
      if(d>=step) thinned.push(b);
    }
    return thinned.length>=2 ? thinned : null;
  }
  window.__fromOverlayPath = fromOverlay;

  function applyFromOverlay(){
    const p = fromOverlay();
    if(!p){ console.warn('[Arrows] No highlight path found'); return; }
    if(!ensureReady()) return;
    window.__arrows_setPath(p, 'HILITE', readOpts());
  }

  document.getElementById('btnApplyFromHighlight')?.addEventListener('click', applyFromOverlay);
  document.getElementById('btnTestArrows')?.addEventListener('click', ()=>{
    const v = document.getElementById('view');
    if(!v || !ensureReady()) return;
    const w=v.width, h=v.height;
    const cx=Math.round(w*0.35), cy=Math.round(h*0.35);
    const p=[{x:cx-80,y:cy},{x:cx+240,y:cy},{x:cx+240,y:cy+160}];
    window.__arrows_setPath(p, 'TEST', readOpts());
  });

  const overlay = document.getElementById('overlay');
  overlay && overlay.addEventListener('mouseup', ()=>{
    if(document.getElementById('chkAutoFromHighlight')?.checked){ applyFromOverlay(); }
  });
})();
// --- Patch: auto-apply arrows from overlay highlight (pinned version) ---
(function(){
  const $ = s=>document.querySelector(s);
  function readOpts(){
    const speedMap=[0,0.25,0.5,0.9,1.3];
    const getI = (id,def)=>{ const el=$(id); return el? parseInt(el.value||def,10):def; };
    const getB = (id)=>!!($(id)&&$(id).checked);
    const val  = (id,def)=> $(id)?.value || def;
    return {
      step:getI('#rngChevronSpace',52), size:getI('#rngChevronSize',18),
      marching:getB('#chkChevronMarch'), speed:speedMap[getI('#rngChevronSpeed',2)]||0.9,
      labelShow:getB('#chkLabelShow'), labelSize:getI('#rngLabelSize',14),
      arrowColor:val('#colArrow','#6bb2ff'), labelBg:val('#colLabelBg','#141820'), labelFg:val('#colLabelFg','#e8eef7'),
      arrowStyle:val('#selArrowStyle','triangle'), startOffset:getI('#rngStartOffset',12), autoDensity:getB('#chkAutoDensity')
    };
  }
  function fromOverlay(){
    const ov = document.getElementById('overlay');
    if(!ov) return null;
    const ctx = ov.getContext('2d');
    const w=ov.width, h=ov.height;
    if(w*h===0) return null;
    const img = ctx.getImageData(0,0,w,h);
    const a = img.data;
    const pts = [];
    const rowStep = Math.max(2, Math.floor(Math.max(w,h)/600));
    const redish = (i)=>{ const r=a[i], g=a[i+1], b=a[i+2], al=a[i+3]; return al>10 && r > 150 && r > g+20; };
    for(let y=0; y<h; y+=rowStep){
      let bestLen=0, bestMid=-1, runLen=0, runStart=-1;
      for(let x=0; x<w; x++){
        const i=(y*w+x)*4;
        if(redish(i)){
          if(runLen===0) runStart=x;
          runLen++;
        }else if(runLen){
          if(runLen>bestLen){ bestLen=runLen; bestMid = Math.round((runStart + (x-1))/2); }
          runLen=0; runStart=-1;
        }
      }
      if(runLen && runLen>bestLen){ bestLen=runLen; bestMid = Math.round((runStart + (w-1))/2); }
      if(bestLen>8 && bestMid>=0){ pts.push({x:bestMid, y}); }
    }
    if(pts.length<2) return null;
    pts.sort((p,q)=> p.y===q.y ? p.x-q.x : p.y-q.y);
    const thinned=[pts[0]];
    const step = 12;
    for(let i=1;i<pts.length;i++){
      const a=thinned[thinned.length-1], b=pts[i];
      const d=Math.hypot(b.x-a.x, b.y-a.y);
      if(d>=step) thinned.push(b);
    }
    return thinned.length>=2 ? thinned : null;
  }
  function applyFromOverlay(){
    const p = fromOverlay(); if(!p) return;
    if(window.__arrows_setPath) window.__arrows_setPath(p, 'HILITE', readOpts());
  }
  document.getElementById('btnApplyFromHighlight')?.addEventListener('click', applyFromOverlay);
  document.getElementById('btnTestArrows')?.addEventListener('click', ()=>{
    const v = document.getElementById('view'); if(!v) return;
    const w=v.width, h=v.height; const cx=Math.round(w*0.35), cy=Math.round(h*0.35);
    const p=[{x:cx-80,y:cy},{x:cx+240,y:cy},{x:cx+240,y:cy+160}];
    if(window.__arrows_setPath) window.__arrows_setPath(p, 'TEST', readOpts());
  });
  const overlay = document.getElementById('overlay');
  overlay && overlay.addEventListener('mouseup', ()=>{
    if(document.getElementById('chkAutoFromHighlight')?.checked){ applyFromOverlay(); }
  });
})();
// ===== Manual Arrows Engine (robust) =====\n
// Compute real polyline length for smoother wrap timing
function __arrows_computePathLength(path){
  if (!path || path.length < 2) return 0;
  let len = 0;
  for (let i=1;i<path.length;i++){
    const dx = path[i].x - path[i-1].x;
    const dy = path[i].y - path[i-1].y;
    len += Math.hypot(dx, dy);
  }
  return len;
}

(function(){
  const arrowsCanvas = window.arrowsCanvas;
  const actx = window.arrowsCtx;
  if(!arrowsCanvas || !actx){ console.warn('Manual Arrows: canvas/context missing'); return; }
  const q = (id)=> document.getElementById(id);
  const UI = {
    enable: q('chkChevronEnable'),
    march: q('chkChevronMarch'),
    labelShow: q('chkLabelShow'),
    space: q('rngChevronSpace'),
    size: q('rngChevronSize'),
    speed: q('rngChevronSpeed'),
    labelSize: q('rngLabelSize'),
    style: q('selArrowStyle'),
    startOffset: q('rngStartOffset'),
    autoDensity: q('chkAutoDensity'),
    colArrow: q('colArrow'),
    colLabelBg: q('colLabelBg'),
    colLabelFg: q('colLabelFg'),
    applyFromHl: q('btnApplyFromHighlight'),
    test: q('btnTestArrows')
  };
  const state = { pathImg:[], totalLen:0, offset:0, anim:false, needsRedraw:true };
  function readSettings(){ return {
          enable: !!(UI.enable && UI.enable.checked),
    march: !!(UI.march && UI.march.checked),
    labelShow: !!(UI.labelShow && UI.labelShow.checked),
    space: Math.max(8, parseInt(UI.space?.value||'52',10)),
    size: Math.max(6, parseInt(UI.size?.value||'18',10)),
    speed: Math.max(0, parseInt(UI.speed?.value||'2',10)),
    labelSize: Math.max(10, parseInt(UI.labelSize?.value||'14',10)),
    style: UI.style?.value || 'triangle',
    startOffset: Math.max(0, parseInt(UI.startOffset?.value||'12',10)),
    autoDensity: !!(UI.autoDensity && UI.autoDensity.checked),
    colArrow: UI.colArrow?.value || '#6bb2ff',
    colLabelBg: UI.colLabelBg?.value || '#141820',
    colLabelFg: UI.colLabelFg?.value || '#e8eef7',
  };}
  function imgPathToScreen(pathImg){ return pathImg.map(p=>{ const s=imgToScreen(p.x,p.y); return {x:s[0],y:s[1]}; }); }
  function pathLength(path){ let L=0; for(let i=1;i<path.length;i++){ const dx=path[i].x-path[i-1].x, dy=path[i].y-path[i-1].y; L+=Math.hypot(dx,dy);} return L; }
  function sampleAt(path, dist){ if(path.length<2) return null; let d=0; for(let i=1;i<path.length;i++){ const A=path[i-1],B=path[i]; const seg=Math.hypot(B.x-A.x,B.y-A.y); if(d+seg>=dist){ const t=(dist-d)/(seg||1); const x=A.x+(B.x-A.x)*t, y=A.y+(B.y-A.y)*t, th=Math.atan2(B.y-A.y,B.x-A.x); return {x,y,theta:th}; } d+=seg; } const Z=path[path.length-1],Y=path[path.length-2]; return {x:Z.x,y:Z.y,theta:Math.atan2(Z.y-Y.y,Z.x-Y.x)}; }
  function drawTriangle(ctx,x,y,theta,size,color){ const w=size,h=Math.max(6,size*1.2); ctx.save(); ctx.translate(x,y); ctx.rotate(theta); ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(-w*0.4,-h*0.4); ctx.lineTo(-w*0.4,h*0.4); ctx.lineTo(w*0.6,0); ctx.closePath(); ctx.fill(); ctx.restore(); }
  function drawChevronShape(ctx,x,y,theta,size,color){ const w=size*1.2,l=size*0.7; ctx.save(); ctx.translate(x,y); ctx.rotate(theta); ctx.strokeStyle=color; ctx.lineWidth=Math.max(1,Math.round(size/6)); ctx.beginPath(); ctx.moveTo(-w*0.3,-l); ctx.lineTo(w*0.4,0); ctx.lineTo(-w*0.3,l); ctx.stroke(); ctx.restore(); }
  function drawDot(ctx,x,y,theta,size,color){ ctx.save(); ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,Math.max(2,size*0.35),0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawLabel(ctx, pathScr, text, sizePx, colBg, colFg){ if(!pathScr.length) return; const p0=pathScr[0]; const pad=6; ctx.save(); ctx.font=`${sizePx}px system-ui, -apple-system, Segoe UI, Roboto`; const w=Math.ceil(ctx.measureText(text).width)+pad*2; const h=Math.ceil(sizePx*1.2)+pad*2; const x=p0.x+8, y=p0.y-h-4; const r=6; ctx.fillStyle=colBg; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle=colFg; ctx.textBaseline='middle'; ctx.fillText(text,x+pad,y+h/2); ctx.restore(); }
  function drawFrame(){ if(!state.needsRedraw && !state.anim) return; actx.setTransform(1,0,0,1,0,0); actx.clearRect(0,0,arrowsCanvas.width,arrowsCanvas.height);
    const S=readSettings(); if(!S.enable || state.pathImg.length<2){ state.needsRedraw=false; return; }
    const pathScr=imgPathToScreen(state.pathImg); const total=pathLength(pathScr); if(total<=1){ state.needsRedraw=false; return; }
    let base=S.startOffset+(state.offset||0); const space=Math.max(10,S.space);
    const n=Math.ceil((total-base)/space);
    for(let i=0;i<n;i++){ const P=sampleAt(pathScr, base+i*space); if(!P) break;
      if(S.style==='triangle') drawTriangle(actx,P.x,P.y,P.theta,S.size,S.colArrow);
      else if(S.style==='chevron') drawChevronShape(actx,P.x,P.y,P.theta,S.size,S.colArrow);
      else drawDot(actx,P.x,P.y,P.theta,S.size,S.colArrow);
    }
    if(S.labelShow){
      let labelText='NET';
      try{ if(typeof activeNet!=='undefined' && activeNet>=0 && netLabels && netLabels[activeNet] && netLabels[activeNet].name){ labelText = netLabels[activeNet].name || 'NET'; } }catch(_){}
      drawLabel(actx, pathScr, labelText, S.labelSize, S.colLabelBg, S.colLabelFg);
    }
    state.needsRedraw=false;
  }
  let rafId=null,lastT=0;
  function onFrame(t){ rafId=null; const S=readSettings(); const dt=Math.max(0,Math.min(100,t-(lastT||t)))/1000; lastT=t; const pxps = S.speed*60; if(state.anim && pxps>0){ state.offset=(state.offset+dt*pxps)%Math.max(1,(state.totalLen||1000)); state.needsRedraw=true; } drawFrame(); if(state.anim && (S.march && S.enable)) rafId=requestAnimationFrame(onFrame); }
  function startAnim(){ const S=readSettings(); const need=!!(S.march && S.enable); if(need && !rafId){ state.anim=true; lastT=0; rafId=requestAnimationFrame(onFrame);} else if(!need && rafId){ state.anim=false; cancelAnimationFrame(rafId); rafId=null; drawFrame(); } }
  window.__arrows_setPath = function(pathImg){
  try{
    const en = document.getElementById('chkChevronEnable');
    if(en) en.checked = true;
    if(typeof activeNet!=='undefined' && activeNet>=0 && netLabels[activeNet]){
      netLabels[activeNet].arrow = netLabels[activeNet].arrow || {};
      netLabels[activeNet].arrow.enable = true;
      if(netLabels[activeNet].arrow.march){ window.__setArrowAnimActive?.(true); }
    }
  }catch(_){}
 if(!Array.isArray(pathImg)||pathImg.length<2) return; state.pathImg=pathImg.slice(); state.totalLen=0; state.offset=0; state.needsRedraw=true; drawFrame(); startAnim(); };
  window.__setArrowAnimActive = function(on){ if(UI?.march){ UI.march.checked = !!on; } state.anim = !!on; startAnim(); };
  const controls = ['chkChevronEnable','chkChevronMarch','chkLabelShow','rngChevronSpace','rngChevronSize','rngChevronSpeed','rngLabelSize','selArrowStyle','rngStartOffset','chkAutoDensity','colArrow','colLabelBg','colLabelFg'];
  controls.forEach(id=> q(id)?.addEventListener('input', ()=>{ state.needsRedraw=true; drawFrame(); startAnim(); }));
  const _drawBase = drawBase; drawBase = function(){ _drawBase(); state.needsRedraw=true; drawFrame(); };
  const _redrawOverlay = redrawOverlay; redrawOverlay = function(){ _redrawOverlay(); state.needsRedraw=true; drawFrame(); };
  const _setCanvasSizeToContainer = setCanvasSizeToContainer; setCanvasSizeToContainer = function(){ _setCanvasSizeToContainer(); state.needsRedraw=true; drawFrame(); };
})(); // ===== /Manual Arrows Engine =====

</script>

<script>
/* ===============================================================
   Cleanup v3f — invert toggle + prefer H/V + robust single-run
   =============================================================== */
(function(){
  // -------- helpers to access app globals even if declared with let --------
  const G = {
    get imgLoaded(){ try{ return imgLoaded; }catch(e){ return window.imgLoaded; } },
    get rawImageData(){ try{ return rawImageData; }catch(e){ return window.rawImageData; } },
    get imgW(){ try{ return imgW; }catch(e){ return window.imgW; } },
    get imgH(){ try{ return imgH; }catch(e){ return window.imgH; } },
    get viewScale(){ try{ return viewScale; }catch(e){ return window.viewScale; } },
    get octx(){ try{ return octx; }catch(e){ return window.octx; } },
    get ctx(){ try{ return ctx; }catch(e){ return window.ctx; } },
    get redrawOverlay(){ try{ return redrawOverlay; }catch(e){ return window.redrawOverlay; } },
    get logHistory(){ try{ return logHistory; }catch(e){ return window.logHistory; } },
    get applyViewTransform(){ try{ return applyViewTransform; }catch(e){ return window.applyViewTransform; } },
  };

  // -------- locate Cleanup panel and add UI toggles --------
  function $(id){ return document.getElementById(id); }
  function addToggleRow(){
    // try to place toggles under bridge slider or above Run button
    const bridge = $('cleanupBridge');
    const runBtn = $('cleanupRunNow');
    const anchor = bridge?.parentElement || runBtn?.parentElement || document.body;

    const box = document.createElement('div');
    box.id = 'cleanupAdvancedRow';
    box.style.display = 'grid';
    box.style.gridTemplateColumns = 'repeat(3, auto)';
    box.style.gap = '8px';
    box.style.alignItems = 'center';
    box.style.marginTop = '6px';

    function mk(labelText, id){
      const wrap = document.createElement('label');
      wrap.style.display='inline-flex';
      wrap.style.alignItems='center';
      wrap.style.gap='6px';
      const cb = document.createElement('input');
      cb.type='checkbox'; cb.id=id;
      const sp = document.createElement('span');
      sp.textContent = labelText;
      wrap.appendChild(cb); wrap.appendChild(sp);
      return wrap;
    }

    // Create: Invert input, Prefer H lines, Prefer V lines
    box.appendChild(mk('Invert input', 'cleanupInvert'));
    box.appendChild(mk('Prefer H lines', 'cleanupPreferH'));
    box.appendChild(mk('Prefer V lines', 'cleanupPreferV'));

    // Avoid duplicates
    if (!$('cleanupAdvancedRow')){
      (anchor).appendChild(box);
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', addToggleRow);
  } else addToggleRow();

  // -------- Engine state --------
  const enabledEl  = $('cleanupEnabled');
  const thickEl    = $('cleanupThickness');
  const bridgeEl   = $('cleanupBridge');
  const invertEl   = $('cleanupInvert');
  const prefHEl    = $('cleanupPreferH');
  const prefVEl    = $('cleanupPreferV');
  const runBtn     = $('cleanupRunNow');
  const clearBtn   = $('cleanupClearMarkers');

  let H = []; // horizontal segments [{y,x0,x1}]
  let V = []; // vertical   segments [{x,y0,y1}]
  let running=false, lastRun=0;

  // -------- Overlay drawing --------
  window.drawCleanupOverlay = function(ctx){
    try{
      if (!G.imgLoaded || !enabledEl?.checked) return;
      if (H.length===0 && V.length===0) return;

      ctx.save();
      if (typeof G.applyViewTransform === 'function') G.applyViewTransform(ctx);

      const tUI = Number(thickEl?.value || 1.4);
      const scale = 1/Math.max(0.001, (G.viewScale||1));
      const lw = tUI*scale;
      const under = (tUI + 1.0 + Number(bridgeEl?.value||0))*scale;

      ctx.lineCap='round'; ctx.lineJoin='round';

      // undercoat
      ctx.globalCompositeOperation='source-over';
      ctx.strokeStyle='#ffffff';
      ctx.lineWidth=under;
      for (const s of H){ ctx.beginPath(); ctx.moveTo(s.x0 - G.imgW/2, s.y - G.imgH/2); ctx.lineTo(s.x1 - G.imgW/2, s.y - G.imgH/2); ctx.stroke(); }
      for (const s of V){ ctx.beginPath(); ctx.moveTo(s.x - G.imgW/2, s.y0 - G.imgH/2); ctx.lineTo(s.x - G.imgW/2, s.y1 - G.imgH/2); ctx.stroke(); }

      // black ink
      ctx.strokeStyle='#000000';
      ctx.lineWidth=lw;
      for (const s of H){ ctx.beginPath(); ctx.moveTo(s.x0 - G.imgW/2, s.y - G.imgH/2); ctx.lineTo(s.x1 - G.imgW/2, s.y - G.imgH/2); ctx.stroke(); }
      for (const s of V){ ctx.beginPath(); ctx.moveTo(s.x - G.imgW/2, s.y0 - G.imgH/2); ctx.lineTo(s.x - G.imgW/2, s.y1 - G.imgH/2); ctx.stroke(); }

      ctx.restore();
    }catch(e){ console.warn('drawCleanupOverlay error', e); }
  };

  // -------- Runner (debounced) --------
  window.__cleanupV3_run = async function(){
    const now = performance.now();
    if (running || (now - lastRun) < 250) return;
    running = true; lastRun = now;
    try{
      G.logHistory?.('[cleanup] starting…');

      // Grayscale
      const g = toGray(G.rawImageData, G.imgW, G.imgH);

      // Threshold (adaptive Bradley)
      const bin = adaptiveBradley(g, G.imgW, G.imgH, 31, 0.15);

      // Optional invert
      if (invertEl?.checked){
        for (let i=0;i<bin.length;i++) bin[i] = bin[i]?0:1;
      }

      // Despeckle
      despeckle(bin, G.imgW, G.imgH);

      // Long-run keeper with preference bias
      const baseL = Math.max(4, 4 + Math.round(Number(bridgeEl?.value||0)*2));
      let Lh = baseL, Lv = baseL;
      const preferH = !!prefHEl?.checked, preferV = !!prefVEl?.checked;
      if (preferH && !preferV){ Lh = Math.max(2, baseL-2); Lv = baseL+2; }
      if (preferV && !preferH){ Lv = Math.max(2, baseL-2); Lh = baseL+2; }

      const keepH = keepLongRunsH(bin, G.imgW, G.imgH, Lh);
      const keepV = keepLongRunsV(bin, G.imgW, G.imgH, Lv);
      // merge masks
      const keep = new Uint8Array(G.imgW*G.imgH);
      for (let i=0;i<keep.length;i++) keep[i] = (keepH[i] | keepV[i]);

      // Extract segments
      const segsH = [];
      for (let y=0;y<G.imgH;y++){
        let x=0;
        while (x<G.imgW){
          while (x<G.imgW && !keep[y*G.imgW+x]) x++;
          const x0=x;
          while (x<G.imgW && keep[y*G.imgW+x]) x++;
          const x1=x-1;
          if (x1>=x0 && (x1-x0+1)>=Lh) segsH.push({y, x0, x1});
        }
      }
      const segsV = [];
      for (let x=0;x<G.imgW;x++){
        let y=0;
        while (y<G.imgH){
          while (y<G.imgH && !keep[y*G.imgW+x]) y++;
          const y0=y;
          while (y<G.imgH && keep[y*G.imgW+x]) y++;
          const y1=y-1;
          if (y1>=y0 && (y1-y0+1)>=Lv) segsV.push({x, y0, y1});
        }
      }

      H = mergeColinearH(segsH, 2);
      V = mergeColinearV(segsV, 2);

      G.logHistory?.(`Cleanup v3f: H=${H.length} V=${V.length} (Lh=${Lh}, Lv=${Lv}) • ${(performance.now()-now|0)} ms`);

      // Turn on overlay so change is visible
      if (enabledEl && !enabledEl.checked){ enabledEl.checked = true; }

      G.redrawOverlay?.();
      G.logHistory?.('[cleanup] done.');
    }catch(e){
      console.error(e);
      G.logHistory?.('[cleanup] error — see console');
    }finally{
      running=false;
    }
  };

  // Click/clear bindings + shift+C + optional auto-run-on-load
  (function bind(){
    const runBtn = $('cleanupRunNow');
    const clearBtn = $('cleanupClearMarkers');
    runBtn?.addEventListener('click', (e)=>{ e.preventDefault(); __cleanupV3_run(); });
    clearBtn?.addEventListener('click', ()=>{ H.length=0; V.length=0; G.redrawOverlay?.(); });
    document.addEventListener('keydown', (e)=>{
      if (e.shiftKey && (e.key==='c'||e.key==='C')){ e.preventDefault(); __cleanupV3_run(); }
    });
    // Auto-run once if a "cleanup auto" checkbox exists and is checked
    let autoFired=false;
    const t = setInterval(()=>{
      try{
        if (G.imgLoaded){
          clearInterval(t);
          const auto = $('cleanupAuto') || $('cleanupAutoAfterTrace') || $('cleanupAutoRun');
          if (auto && (auto.checked || auto.getAttribute('data-default')==='true') && !autoFired){
            autoFired=true;
            G.logHistory?.('[cleanup] auto-run on image load');
            __cleanupV3_run();
          }
        }
      }catch(e){}
    }, 300);
  })();

  // Hook into redrawOverlay to render our overlay
  if (typeof G.redrawOverlay === 'function' && !window.__cleanupHookedV3f){
    const __orig = G.redrawOverlay;
    window.redrawOverlay = function(){
      try { __orig.apply(this, arguments); } finally {
        const ctx = (arguments[0] && arguments[0].canvas) ? arguments[0] : (G.octx || G.ctx || null);
        if (ctx) window.drawCleanupOverlay(ctx);
      }
    };
    window.__cleanupHookedV3f = true;
  }

  // ------------------- image ops -------------------
  function toGray(rgba,w,h){
    const src = rgba.data || rgba;
    const g = new Uint8Array(w*h);
    for (let i=0,j=0;i<g.length;i++,j+=4){
      g[i] = (0.2126*src[j] + 0.7152*src[j+1] + 0.0722*src[j+2])|0;
    }
    return g;
  }

  function adaptiveBradley(gray,w,h, win, t){
    const ii = new Uint32Array((w+1)*(h+1));
    for (let y=1;y<=h;y++){
      let rowsum=0;
      for (let x=1;x<=w;x++){
        const v = gray[(y-1)*w + (x-1)];
        rowsum += v;
        ii[y*(w+1)+x] = ii[(y-1)*(w+1)+x] + rowsum;
      }
    }
    const out = new Uint8Array(w*h);
    const half = Math.max(1, win>>1);
    for (let y=0;y<h;y++){
      const y0 = Math.max(0, y-half), y1 = Math.min(h-1, y+half);
      for (let x=0;x<w;x++){
        const x0 = Math.max(0, x-half), x1 = Math.min(w-1, x+half);
        const A = ii[y0*(w+1)+x0], B = ii[y0*(w+1)+(x1+1)];
        const C = ii[(y1+1)*(w+1)+x0], D = ii[(y1+1)*(w+1)+(x1+1)];
        const area = (x1-x0+1)*(y1-y0+1);
        const mean = (D - B - C + A) / area;
        const v = gray[y*w+x];
        out[y*w+x] = (v <= mean*(1 - t)) ? 1 : 0;
      }
    }
    return out;
  }

  function despeckle(img,w,h){
    const copy = img.slice(0);
    const idx=(x,y)=>y*w+x;
    const inb=(x,y)=> x>=0 && y>=0 && x<w && y<h;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const i=idx(x,y);
        if (!copy[i]) continue;
        let s=0;
        for (let dy=-1;dy<=1;dy++){
          for (let dx=-1;dx<=1;dx++){
            if (!dx && !dy) continue;
            const xx=x+dx, yy=y+dy;
            if (inb(xx,yy)) s += copy[idx(xx,yy)];
          }
        }
        if (s<=1) img[i]=0;
      }
    }
  }

  function keepLongRunsH(bin,w,h,L){
    const out = new Uint8Array(w*h);
    for (let y=0;y<h;y++){
      let x=0;
      while (x<w){
        while (x<w && bin[y*w+x]===0) x++;
        const x0=x;
        while (x<w && bin[y*w+x]===1) x++;
        const x1=x-1, len=x1-x0+1;
        if (len>=L){ for (let X=x0; X<=x1; X++) out[y*w+X]=1; }
      }
    }
    return out;
  }
  function keepLongRunsV(bin,w,h,L){
    const out = new Uint8Array(w*h);
    for (let x=0;x<w;x++){
      let y=0;
      while (y<h){
        while (y<h && bin[y*w+x]===0) y++;
        const y0=y;
        while (y<h && bin[y*w+x]===1) y++;
        const y1=y-1, len=y1-y0+1;
        if (len>=L){ for (let Y=y0; Y<=y1; Y++) out[Y*w+x]=1; }
      }
    }
    return out;
  }

  function mergeColinearH(segs, gap){
    segs.sort((a,b)=> a.y-b.y || a.x0-b.x0);
    const out=[];
    for (const s of segs){
      const last = out[out.length-1];
      if (last && last.y===s.y && s.x0 <= last.x1 + gap) last.x1 = Math.max(last.x1, s.x1);
      else out.push({...s});
    }
    return out;
  }
  function mergeColinearV(segs, gap){
    segs.sort((a,b)=> a.x-b.x || a.y0-b.y0);
    const out=[];
    for (const s of segs){
      const last = out[out.length-1];
      if (last && last.x===s.x && s.y0 <= last.y1 + gap) last.y1 = Math.max(last.y1, s.y1);
      else out.push({...s});
    }
    return out;
  }
})();
</script>

<script>
// === One-click "Scan Polish" preset ===
(function(){
  function safe(fn){ try{ return fn&&fn(); }catch(_){ } }
  function show(title,text){ 
    const m=document.getElementById('progressModal'); if(!m) return; 
    m.style.display='flex';
    const t=document.getElementById('progressTitle'); if(t) t.textContent=title||'Working…';
    const p=document.getElementById('progressText'); if(p) p.textContent=text||'';
    const b=document.getElementById('progressBarFill'); if(b) b.style.width='0%';
  }
  function step(pct,text){
    const p=document.getElementById('progressText'); if(p&&text) p.textContent=text;
    const b=document.getElementById('progressBarFill'); if(b) b.style.width=Math.max(0,Math.min(100,pct|0))+'%';
  }
  function hide(){ const m=document.getElementById('progressModal'); if(m) m.style.display='none'; }

  async function runScanPolishPreset(){
    try{
      if(!window.__imgReady){ alert('Load an image first.'); return; }
      show('Scan Polish','Analyzing…'); await new Promise(r=>requestAnimationFrame(r));

      // 1) Auto threshold
      try{
        const chk=document.getElementById('autoThresh'); if(chk) chk.checked=true;
        document.getElementById('analyze')?.click();
        step(30,'Auto threshold set');
      }catch(_){}

      // 2) Cleanup
      try{
        const en=document.getElementById('cleanupEnabled'); if(en && !en.checked) en.click();
        const th=document.getElementById('cleanupThickness'); const br=document.getElementById('cleanupBridge');
        const thv=document.getElementById('cleanupThicknessVal'); const brv=document.getElementById('cleanupBridgeVal');
        if(th){ th.value=0.75; if(thv) thv.textContent='0.75 px'; }
        if(br){ br.value=0.5;  if(brv) brv.textContent='0.5 px'; }
        safe(window.syncCleanupUI);
        step(55,'Cleanup…');
        if(typeof window.runCleanupWithProgress==='function'){ await window.runCleanupWithProgress(); }
        else if(typeof window.__cleanupV3_run==='function'){ window.__cleanupV3_run(); }
        else { safe(window.redrawOverlay); }
      }catch(_){}

      // 3) Text cleanup
      try{
        const tOn=document.getElementById('textCleanEnabled'); if(tOn) tOn.checked=true;
        step(80,'Text cleanup…');
        if(typeof window.runTextCleanupWithProgress==='function'){ await window.runTextCleanupWithProgress(); }
        else if(typeof window.buildTextCleanup==='function'){ window.buildTextCleanup(); safe(window.redrawOverlay); }
      }catch(_){}

      // 4) Auto-label VCC/GND from annotations
      try{
        step(95,'Auto-label power nets…');
        (function autoLabel(){
          const anns = window.annotations||[]; const have=new Set((window.netLabels||[]).map(n=>(n?.name||'').toUpperCase()));
          const targets=['VCC','GND']; let added=0;
          for(const a of anns){
            const t=(a?.text||'').trim().toUpperCase();
            if(targets.includes(t) && !have.has(t)){
              if(typeof window.labelNetAt==='function'){ window.labelNetAt(a.x,a.y,t); have.add(t); added++; }
            }
          }
          if(added>0){ safe(window.refreshNetsList); safe(window.redrawOverlay); }
        })();
      }catch(_){}

      step(100,'Done');
      safe(()=>window.logHistory?.('[preset] Scan Polish completed'));
    } finally {
      setTimeout(hide, 120);
      safe(window.redrawOverlay);
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // mark readiness when image loads (patch ingestBitmap)
    if(typeof window.ingestBitmap==='function' && !window.ingestBitmap.__patchedReady){
      const __orig = window.ingestBitmap;
      window.ingestBitmap = function(){
        const r = __orig.apply(this, arguments);
        window.__imgReady = true;
        return r;
      };
      window.ingestBitmap.__patchedReady = true;
    }
    const b=document.getElementById('scanPolishBtn'); if(b) b.addEventListener('click', runScanPolishPreset);
  });
})();
</script>



<script>
// === Find Opens/Tees v3 (clustered ring logic; fewer false tees; robust readiness) ===
(function(){
  // Mark readiness when an image is ingested
  document.addEventListener('DOMContentLoaded', ()=>{
    if(typeof window.ingestBitmap==='function' && !window.ingestBitmap.__patchedReady3){
      const __orig = window.ingestBitmap;
      window.ingestBitmap = function(){
        const r = __orig.apply(this, arguments);
        window.__imgReady = true;
        return r;
      };
      window.ingestBitmap.__patchedReady3 = true;
    }
  });

  function isReady(){ return !!window.__imgReady; }

  // Ring-cluster classifier on IMAGE coords
  function countRingClusters(ix,iy,threshold){
    const ring = [[0,0,0],[0,0,0],[0,0,0]];
    let neighborCount = 0;
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx = ix+dx, ny = iy+dy;
        if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue;
        if(isInk(nx,ny,threshold)){ ring[dy+1][dx+1] = 1; neighborCount++; }
      }
    }
    // Connected components on the 3x3 ring (8-connectivity)
    let comps=0;
    const seen=[[0,0,0],[0,0,0],[0,0,0]];
    const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    function flood(i,j){
      const q=[[i,j]]; seen[i][j]=1;
      while(q.length){
        const [a,b]=q.shift();
        for(const [di,dj] of dirs){
          const ni=a+di, nj=b+dj;
          if(ni<0||nj<0||ni>2||nj>2) continue;
          if(!seen[ni][nj] && ring[ni][nj]){ seen[ni][nj]=1; q.push([ni,nj]); }
        }
      }
    }
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        if(ring[i][j] && !seen[i][j]){ comps++; flood(i,j); }
      }
    }
    return { neighborCount, comps, ring };
  }

  function nearSymbol(ix,iy){
    try{
      if(!(window.cleanup?.ignoreSymbols)) return false;
      if(typeof hitTestSymbol!=='function') return false;
      return hitTestSymbol(ix,iy) >= 0;
    }catch(_){ return false; }
  }

  function clusterPoints(pts, radius){
    const out=[]; const r2=radius*radius;
    for(const p of pts){
      let found=false;
      for(const c of out){
        const dx=p.x-c.x, dy=p.y-c.y;
        if(dx*dx+dy*dy<=r2){
          c.x = (c.x*c.n + p.x)/(c.n+1);
          c.y = (c.y*c.n + p.y)/(c.n+1);
          c.n += 1; c.type = c.type || p.type;
          found=true; break;
        }
      }
      if(!found){ out.push({x:p.x, y:p.y, type:p.type, n:1}); }
    }
    return out.map(c=>({x:Math.round(c.x), y:Math.round(c.y), type:c.type}));
  }

  // Draw markers in SCREEN space (zoom-invariant)
  function drawMarkersScreen(ctx, markers){
    if(!markers || !markers.length) return;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    const s = 8;
    for(const m of markers){
      const pt = (typeof imgToScreen==='function') ? imgToScreen(m.x, m.y) : [m.x, m.y];
      const x = pt[0], y = pt[1];
      if(m.type==='end'){
        ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, s, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x-s*0.7,y-s*0.7); ctx.lineTo(x+s*0.7,y+s*0.7);
        ctx.moveTo(x-s*0.7,y+s*0.7); ctx.lineTo(x+s*0.7,y-s*0.7); ctx.stroke();
      } else {
        ctx.strokeStyle = '#6bb2ff'; ctx.lineWidth = 2;
        ctx.strokeRect(x-s, y-s, 2*s, 2*s);
        ctx.beginPath(); ctx.moveTo(x - s*0.9, y); ctx.lineTo(x + s*0.9, y);
        ctx.moveTo(x, y - s*0.9); ctx.lineTo(x, y + s*0.9); ctx.stroke();
      }
    }
    ctx.restore();
  }

  function findOpensAndTees_v3(){
    if(!isReady()){ alert('Load an image first.'); return; }
    const threshold = +((document.getElementById('thresh')||{}).value || 120);
    const cv = document.getElementById('view'); if(!cv) return;
    const ends=[], tees=[];

    // Sample visible region in SCREEN space, project to IMAGE coords
    const step = 2; // screen px stride
    for(let sy=1; sy<cv.height-1; sy+=step){
      for(let sx=1; sx<cv.width-1; sx+=step){
        const pix = screenToImg(sx, sy);
        const ix = (pix[0]|0), iy = (pix[1]|0);
        if(ix<1||iy<1||ix>=imgW-1||iy>=imgH-1) continue;
        if(typeof isInk!=='function' || !isInk(ix,iy,threshold)) continue;
        if(nearSymbol(ix,iy)) continue;

        const {neighborCount, comps} = countRingClusters(ix,iy,threshold);

        // Endpoint heuristic: 1 cluster with 1 neighbor (thin) or 2 neighbors but still 1 cluster (fatter line tips)
        if((neighborCount===1 && comps===1) || (neighborCount===2 && comps===1)){
          ends.push({x:ix, y:iy, type:'end'});
          continue;
        }

        // Tee/junction heuristic: at least 3 separated clusters (robust against fat 90° corners)
        if(comps>=3){
          tees.push({x:ix, y:iy, type:'tee'});
        }
      }
    }

    const endsC = clusterPoints(ends, 10);
    const teesC = clusterPoints(tees, 10);
    window.cleanupMarkers = [...teesC, ...endsC];
    try{ window.logHistory && window.logHistory(`Markers: ${teesC.length} tees, ${endsC.length} opens`); }catch(_){}
    try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
    return {tees: teesC.length, opens: endsC.length};
  }

  // Wire buttons
  document.addEventListener('click', (e)=>{
    const el = e.target;
    if(el && el.id === 'cleanupFindBtn'){
      try{ findOpensAndTees_v3(); }catch(_){}
    }
  }, true);

  // Ensure markers render after overlay
  const __redraw = window.redrawOverlay;
  window.redrawOverlay = function(){
    try{ __redraw && __redraw(); }catch(_){}
    try{
      const ctx = (window.octx || (document.getElementById('overlay')?.getContext('2d')));
      drawMarkersScreen(ctx, window.cleanupMarkers||[]);
    }catch(_){}
  };
})();
</script>


<script>
// === Junction Dot Normalizer
(function(){
  // State
  window.junctionCfg = window.junctionCfg || { enabled:false, radius:6 };

  function syncJunctionUI(){
    const en = document.getElementById('junctionNormalize');
    const ra = document.getElementById('junctionRadius');
    const rv = document.getElementById('junctionRadiusVal');
    if(!en || !ra || !rv) return;
    en.checked = !!window.junctionCfg.enabled;
    ra.value = +window.junctionCfg.radius || 6;
    rv.textContent = (Math.round((+ra.value)*10)/10) + ' px';
  }

  function hookUI(){
    const en = document.getElementById('junctionNormalize');
    const ra = document.getElementById('junctionRadius');
    const rv = document.getElementById('junctionRadiusVal');
    if(en){
      en.addEventListener('change', ()=>{
        window.junctionCfg.enabled = !!en.checked;
        try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
      });
    }
    if(ra && rv){
      ra.addEventListener('input', ()=>{
        window.junctionCfg.radius = +ra.value;
        rv.textContent = (Math.round((+ra.value)*10)/10) + ' px';
        try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
      });
    }
    syncJunctionUI();
  }

  function ensureTeeMarkers(){
    if(Array.isArray(window.cleanupMarkers) && window.cleanupMarkers.some(m=>m.type==='tee')) return window.cleanupMarkers;
    try{
      if(typeof findOpensAndTees_v3==='function'){ findOpensAndTees_v3(); }
      else if(typeof findOpensAndTees_v2==='function'){ findOpensAndTees_v2(); }
    }catch(_){}
    return window.cleanupMarkers || [];
  }

  // Draw filled black circles at each tee; overlay uses SCREEN units
  function drawJunctionDots(ctx){
    if(!window.junctionCfg?.enabled) return;
    const r = Math.max(1, +window.junctionCfg.radius || 6);
    const markers = ensureTeeMarkers().filter(m=>m.type==='tee');
    if(!markers.length) return;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    for(const m of markers){
      const pt = (typeof imgToScreen==='function') ? imgToScreen(m.x, m.y) : [m.x, m.y];
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(pt[0], pt[1], r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }
  window.drawJunctionDots = drawJunctionDots;

  // Draw LAST: wrap the most recent redrawOverlay so dots are always on top
  const __prevRedraw = window.redrawOverlay;
  window.redrawOverlay = function(){
    try{ __prevRedraw && __prevRedraw(); }catch(_){}
    try{
      const ctx = (window.octx || (document.getElementById('overlay')?.getContext('2d')));
      drawJunctionDots(ctx);
    }catch(_){}
  };

  // Patch PNG export: scale radius from SCREEN px to IMAGE px using current viewScale
  if(typeof window.drawNetLabels==='function' && !window.drawNetLabels.__junctionExport2){
    const __origDrawNetLabels = window.drawNetLabels;
    window.drawNetLabels = function(ctx, transformed){
      const r = __origDrawNetLabels.apply(this, arguments);
      try{
        if(window.junctionCfg?.enabled && transformed===false){
          const markers = ensureTeeMarkers().filter(m=>m.type==='tee');
          const screenR = Math.max(1, +window.junctionCfg.radius || 6);
          const scale = (typeof window.viewScale==='number' && window.viewScale>0) ? window.viewScale : 1;
          const imgR = Math.max(1, Math.round(screenR / scale)); // convert to image pixels
          ctx.save();
          for(const m of markers){
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(m.x, m.y, imgR, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
      }catch(_){}
      return r;
    };
    window.drawNetLabels.__junctionExport2 = true;
  }

  document.addEventListener('DOMContentLoaded', hookUI);
})();

  // Patch PNG export so dots are baked in
  const dl = document.getElementById('download');
  if(dl && !dl.__junctionPatched){
    dl.__junctionPatched = true;
    dl.addEventListener('click', function(){
      // defer: original handler runs first, but we also draw into export by patching its path
    }, {capture:true});
    // monkey-patch download code if available by wrapping drawNetLabels or after layers drawn
    if(typeof window.drawNetLabels==='function' && !window.drawNetLabels.__junctionExport){
      const __origDrawNetLabels = window.drawNetLabels;
      window.drawNetLabels = function(ctx, transformed){
        const r = __origDrawNetLabels.apply(this, arguments);
        try{
          if(window.junctionCfg?.enabled && transformed===false){
            // ctx here is export canvas context in image coords
            const markers = ensureTeeMarkers().filter(m=>m.type==='tee');
            const rr = Math.max(1, +window.junctionCfg.radius || 6);
            ctx.save();
            for(const m of markers){
              ctx.fillStyle = '#000000';
              ctx.beginPath();
              ctx.arc(m.x, m.y, rr, 0, Math.PI*2);
              ctx.fill();
            }
            ctx.restore();
          }
        }catch(_){}
        return r;
      };
      window.drawNetLabels.__junctionExport = true;
    }
  }

  document.addEventListener('DOMContentLoaded', hookUI);
})();
</script>


<script>
// === OCR (Tesseract.js) — selection + full page =================================
(function(){
  let ocrWorker = null;
  let ocrSelectMode = false;
  let ocrRectEl = null;
  const ocrCfg = { attachNet: true };

  async function initOcr(){
    if(ocrWorker) return ocrWorker;
    if(!window.Tesseract){ alert('Tesseract.js not loaded.'); throw new Error('No Tesseract'); }
    ocrWorker = await Tesseract.createWorker('eng', 1, { logger: m => console.debug('[OCR]', m) });
    return ocrWorker;
  }

  function showProgress(title, text, prog){
    try{
      let modal = document.getElementById('progressModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id='progressModal';
        modal.innerHTML = '<div id="progressCard"><h3 id="progressTitle"></h3><div id="progressText"></div><div class="progressBar"><div id="progressFill"></div></div></div>';
        document.body.appendChild(modal);
      }
      const fill = modal.querySelector('#progressFill');
      modal.style.display='flex';
      modal.querySelector('#progressTitle').textContent = title||'Working…';
      modal.querySelector('#progressText').textContent = text||'';
      if(fill){ fill.style.width = (Math.max(0, Math.min(100, prog||0))) + '%'; fill.style.background = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#6bb2ff'; }
    }catch(e){ console.warn(e); }
  }
  function hideProgress(){
    const modal = document.getElementById('progressModal');
    if(modal) modal.style.display='none';
  }

  function getImageCropCanvas(ix, iy, w, h){
    const c = document.createElement('canvas');
    c.width = Math.max(1, w|0); c.height = Math.max(1, h|0);
    const cx = c.getContext('2d', { willReadFrequently:true });
    cx.drawImage(imgBitmap, ix, iy, w, h, 0, 0, c.width, c.height);
    return c;
  }

  function placeOcrLine(ix, iy, w, h, line){
    const text = (line.text||'').trim();
    if(!text) return;
    const cx = ix + (line.bbox?.x0||0) + ((line.bbox?.x1||0) - (line.bbox?.x0||0))/2;
    const cy = iy + (line.bbox?.y0||0) + ((line.bbox?.y1||0) - (line.bbox?.y0||0))/2;
    if( (document.getElementById('ocrAttachNet')?.checked) && typeof findNearestInkRobust==='function'){
      const hit = findNearestInkRobust(cx|0, cy|0, Math.max(8, (+snap?.value||6)), +thresh?.value||120);
      if(hit && typeof labelNetAt==='function'){
        try{ labelNetAt(hit.x, hit.y, text); return; }catch(_){}
      }
    }
    annotations.push({ x:cx, y:cy, text, size:+(labelSize?.value||18), color:(labelColor?.value||'#ffff00') });
  }

  async function ocrRect(ix, iy, w, h){
    if(!imgLoaded) return alert('Load an image first.');
    const worker = await initOcr();
    showProgress('OCR selection', 'Recognizing…', 10);
    const crop = getImageCropCanvas(ix, iy, w, h);
    const result = await worker.recognize(crop, { tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-_+/VΩkMμ%' });
    try{
      const lines = (result?.data?.lines)||[];
      for(const ln of lines){ placeOcrLine(ix, iy, w, h, ln); }
      redrawOverlay();
      logHistory?.(`OCR selection → ${ (result?.data?.text||'').trim().slice(0,60) }`);
    }finally{ hideProgress(); }
  }
  window.ocrRect = ocrRect;

  async function ocrPage(){
    if(!imgLoaded) return alert('Load an image first.');
    const worker = await initOcr();
    const tile = 900; const overlap = 40;
    let done = 0; const totalX = Math.ceil(imgW / (tile - overlap)); const totalY = Math.ceil(imgH / (tile - overlap));
    const total = totalX * totalY;
    for(let y=0; y<imgH; y += (tile - overlap)){
      const h = Math.min(tile, imgH - y);
      for(let x=0; x<imgW; x += (tile - overlap)){
        const w = Math.min(tile, imgW - x);
        showProgress('OCR page', `Tile ${done+1}/${total}`, (done/total)*100);
        const crop = getImageCropCanvas(x, y, w, h);
        const result = await worker.recognize(crop, { tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-_+/VΩkMμ%' });
        const lines = (result?.data?.lines)||[];
        for(const ln of lines){ placeOcrLine(x, y, w, h, ln); }
        done++;
      }
    }
    hideProgress();
    redrawOverlay();
    logHistory?.(`OCR page complete (${done} tiles).`);
  }
  window.ocrPage = ocrPage;

  function enableOcrSelect(on){
    ocrSelectMode = !!on;
    if(ocrSelectMode){
      if(!ocrRectEl){
        ocrRectEl = document.createElement('div');
        ocrRectEl.className = 'retype-rect';
        ocrRectEl.style.display = 'none';
        document.querySelector('.canvasWrap')?.appendChild(ocrRectEl);
      }
      logHistory?.('OCR selection: drag a box on the canvas.');
    } else {
      if(ocrRectEl) ocrRectEl.style.display = 'none';
    }
  }

  const ocrSelectBtn = document.getElementById('ocrSelectBtn');
  const ocrPageBtn = document.getElementById('ocrPageBtn');
  ocrSelectBtn?.addEventListener('click', ()=> enableOcrSelect(!ocrSelectMode));
  ocrPageBtn?.addEventListener('click', ()=> ocrPage());

  window.addEventListener('keydown', (e)=>{
    const tgt = e.target; const typing = tgt && (tgt.tagName==='INPUT' || tgt.tagName==='TEXTAREA' || tgt.isContentEditable);
    if(!typing && (e.key==='o' || e.key==='O')){
      e.preventDefault();
      enableOcrSelect(!ocrSelectMode);
    }
  });

  let dragStart = null;
  const viewEl = document.getElementById('view');
  function onDown(e){
    if(!ocrSelectMode) return;
    e.preventDefault(); e.stopPropagation();
    dragStart = { sx: e.offsetX, sy: e.offsetY };
    ocrRectEl.style.left = `${dragStart.sx}px`;
    ocrRectEl.style.top  = `${dragStart.sy}px`;
    ocrRectEl.style.width = '1px'; ocrRectEl.style.height='1px';
    ocrRectEl.style.display = 'block';
  }
  function onMove(e){
    if(!dragStart || !ocrSelectMode) return;
    const x1 = Math.min(dragStart.sx, e.offsetX), y1 = Math.min(dragStart.sy, e.offsetY);
    const x2 = Math.max(dragStart.sx, e.offsetX), y2 = Math.max(dragStart.sy, e.offsetY);
    ocrRectEl.style.left = `${x1}px`; ocrRectEl.style.top = `${y1}px`;
    ocrRectEl.style.width = `${x2-x1}px`; ocrRectEl.style.height = `${y2-y1}px`;
  }
  function onUp(e){
    if(!dragStart || !ocrSelectMode) return;
    const x1 = Math.min(dragStart.sx, e.offsetX), y1 = Math.min(dragStart.sy, e.offsetY);
    const x2 = Math.max(dragStart.sx, e.offsetX), y2 = Math.max(dragStart.sy, e.offsetY);
    dragStart = null; ocrRectEl.style.display = 'none'; enableOcrSelect(false);
    const p1 = screenToImg(x1, y1);
    const p2 = screenToImg(x2, y2);
    const ix = Math.max(0, Math.min(imgW-1, Math.floor(Math.min(p1[0], p2[0]))));
    const iy = Math.max(0, Math.min(imgH-1, Math.floor(Math.min(p1[1], p2[1]))));
    const iw = Math.max(1, Math.floor(Math.abs(p2[0]-p1[0])));
    const ih = Math.max(1, Math.floor(Math.abs(p2[1]-p1[1])));
    ocrRect(ix, iy, iw, ih);
  }
  viewEl?.addEventListener('mousedown', onDown, true);
  viewEl?.addEventListener('mousemove', onMove, true);
  viewEl?.addEventListener('mouseup', onUp, true);

  window.addEventListener('beforeunload', ()=>{ try{ ocrWorker && ocrWorker.terminate && ocrWorker.terminate(); }catch(_){} });
})();
</script>
</body>

</html>
