<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Schematic Highlighter — Docking + Tabs (v3.2f: annotation editor fix)</title>
<link rel="stylesheet" href="css/style.css">
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
<header>
  <div class="toolbar toolbar-left" role="toolbar" aria-label="Panels">
    <button id="toggleLeft" class="active">Left</button>
    <button id="toggleRight" class="active">Right</button>
    <button id="toggleBottom" class="active">Bottom</button>
  </div>
  <div class="toolbar toolbar-center" role="toolbar" aria-label="Tools (Top)">
    <button id="topPan">Pan (P)</button>
    <button id="topHighlight" class="active">Highlight (H)</button>
    <button id="topText">Text (T)</button>
    <button id="topEraser">Eraser (E)</button>
    <button id="topLine">Line (L)</button>
    <button id="topNet">Net (N)</button>
    <button id="topCont">Continuity (C)</button>
  
      <button id="cleanupToggle" title="Cleanup mode (redraw black stroke over traced lines)">Cleanup</button>
      <button id="cleanupFindBtn" title="Find opens/tees">Find Opens/Tees</button>
      <button id="cleanupSettingsBtn" title="Cleanup settings">⚙</button>

      <button id="retypeToggle" title="Retype (R): box old text then type new">Retype (R)</button>
    <button id="topArrows" title="Manual Arrows">Arrows</button>
  </div>
  <div class="toolbar toolbar-right" role="toolbar" aria-label="Actions">
    <button id="fit">Fit</button>
    <button id="clear">Clear</button>
    <button id="download">PNG</button>
    <button id="scanPolishBtn" title="One-click: auto threshold → cleanup → text cleanup → auto-label VCC/GND">Scan Polish</button>
    <button id="saveProject">Save Project</button>
    <button id="openProjectBtn">Open</button>
    <button id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
    <button id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
    <input id="openProject" type="file" accept="application/json" style="display:none" />
  </div>

</header>

<div id="dock" class="dock">

  <button id="revealLeft" class="reveal left" title="Show left panel" aria-label="Show left panel">
    <svg viewBox="0 0 24 24"><polyline points="14 6 8 12 14 18"/></svg>
  </button>
  <button id="revealRight" class="reveal right" title="Show right panel" aria-label="Show right panel">
    <svg viewBox="0 0 24 24"><polyline points="10 6 16 12 10 18"/></svg>
  </button>
  <button id="revealBottom" class="reveal bottom" title="Show bottom panel" aria-label="Show bottom panel">
    <svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg>
  </button>

  <aside id="leftPanel" class="panel">
  <button id="chevLeft" class="chev chev-left" title="Hide left panel" aria-label="Hide left panel">
  <svg viewBox="0 0 24 24"><polyline points="14 6 8 12 14 18"/></svg>
</button>
    <div>
      <h2>1) Load schematic image</h2>
      <div class="row"><input id="file" type="file" accept="image/*"></div>
      <div id="drop" class="drop">…or drag & drop an image here</div>
      <div class="row" style="margin-top:6px;gap:6px;grid-template-columns:auto 1fr;">
        <button id="loadSample">Load sample</button>
        <div class="hint">PNG (black lines on white) gives best results. PDFs need to be exported to an image first.</div>
      </div>
    </div>

    <div>
      <h2>2) Tools</h2>
      <div class="row" style="grid-template-columns:repeat(3, auto) 1fr; gap:8px; align-items:center;">
        <button id="panToggle">Pan (P)</button>
        <button id="highlightToggle" class="active">Highlight (H)</button>
        <button id="textMode">Text (T)</button>
        <button id="eraserToggle">Eraser (E)</button>
        <button id="lineToggle">Line (L)</button>
      </div>
      <div class="row" style="grid-template-columns:repeat(2, auto) 1fr; gap:8px; align-items:center; margin-top:6px;">
        <button id="netLabelMode">Net Label (N)</button>
        <button id="contToggle">Continuity (C)</button>
        <div class="hint">Net Label: click a wire to name it. Continuity: pick two pins → pass/fail.</div>
      </div>
      <div class="row"><label for="eraserSize">Eraser size (px)</label><output id="eraserSizeVal">10</output></div>
      <input id="eraserSize" type="range" min="2" max="48" step="1" value="10">
      <div class="row"><label class="inline" style="display:flex;align-items:center;gap:6px;"><input id="eraseImageTarget" type="checkbox"> Erase base image</label></div>
      <div class="hint">Eraser clears the <b>active layer</b>. Enable “Erase base image” to remove pixels from the loaded image. Use <b>Line</b> to draw straight highlight segments.</div>
    </div>

    <div>
      <h2>Tracing</h2>
      <div class="hint">Click near a thin black line to trace the connected stroke. <b>Middle-click</b> or hold <span class="kbd">Space</span> to pan. <b>Wheel = zoom</b>. Shift+Click to clear first.</div>
      <label class="inline" style="display:flex;align-items:center;gap:8px;"><input type="checkbox" id="segmentMode" checked> Stop at junctions (segment between tees/symbols)</label>
    </div>

    <div>
      <h2>Threshold</h2>
      <label class="inline"><input type="checkbox" id="autoThresh" checked> Auto-detect dark-line threshold</label>
      <div class="row"><label for="thresh">Manual threshold</label><output id="threshVal">120</output></div>
      <input id="thresh" type="range" min="0" max="255" value="120" step="1">
      <div class="row" style="grid-template-columns:auto auto 1fr; gap:8px;">
        <button id="analyze">Analyze</button>
        <div class="hint">Auto picks a value using Otsu on luminance histogram.</div>
      </div>
    </div>

    <div>
      <h2>Performance</h2>
      <label class="inline"><input type="checkbox" id="autoDown" checked> Auto-downscale large images</label>
      <div class="row"><label for="maxDim">Max dimension (px)</label><output id="maxDimVal">4096</output></div>
      <input id="maxDim" type="number" min="512" max="8192" step="128" value="4096">
    </div>

    <div class="footer">All local. No uploads.</div>
  </aside>

  <div id="splitLeft" class="splitter v left"></div>

  <main class="canvasWrap">
    <canvas id="view" width="1280" height="800"></canvas>
    <canvas id="overlay" width="1280" height="800"></canvas>
    <canvas id="arrowsCanvas" width="1280" height="800" style="pointer-events:none;background:transparent"></canvas>
    <input id="labelEditor" class="labelEditor" placeholder="Type and Enter…" />
  </main>

  <div id="splitRight" class="splitter v right"></div>

  <aside id="rightPanel" class="panel">
  <button id="chevRight" class="chev chev-right" title="Hide right panel" aria-label="Hide right panel">
  <svg viewBox="0 0 24 24"><polyline points="10 6 16 12 10 18"/></svg>
</button>
    <div class="tabs" id="rightTabs">
      <button data-tab="props" class="active">Properties</button>
      <button data-tab="layers">Layers</button>
      <button data-tab="symbols">Symbols</button>
      <button data-tab="nets">Nets</button>
    
      <button data-tab="cleanup">Cleanup</button>
    
      <button data-tab="text">Text</button>
    </div>
    <div class="sep"></div>

    <section id="tab-props" class="tabpane active">
      <div>
        <h2>Text annotations</h2>
        <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px; align-items:center;">
          <label class="inline" style="gap:6px;">Color <input id="labelColor" type="color" value="#ffff00"></label>
          <label class="inline" style="gap:6px;">Size <output id="labelSizeVal">18</output>px</label>
        </div>
        <input id="labelSize" type="range" min="10" max="48" value="18" step="1">
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="showAnnotations" type="checkbox" checked> Show annotations</label>
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="showNetLabels" type="checkbox" checked> Show net labels</label>
        <label style="display:flex;gap:8px;align-items:center;margin-top:4px;"><input id="contFree" type="checkbox"> Free continuity (click any two points)</label>
      </div>

      <div>
        <h2>Highlight & Limits</h2>
        <div class="row"><label for="snap">Snap radius (px)</label><output id="snapVal">6</output></div>
        <input id="snap" type="range" min="0" max="20" value="6" step="1">
        <div class="row"><label for="alpha">Default opacity</label><output id="alphaVal">0.70</output></div>
        <input id="alpha" type="range" min="0" max="100" value="70" step="1">
        <div class="row"><label for="color">Default color</label><input id="color" type="color" value="#ff0000"></div>
        <div class="row" style="grid-template-columns:auto 1fr;">
          <button id="autoColor">Auto line color (A)</button>
          <div></div>
        </div>
        <div class="row"><label for="thickness">Highlight thickness (px)</label><output id="thicknessVal">6</output></div>
        <input id="thickness" type="range" min="1" max="24" value="6" step="1">
        <div class="row"><label for="limit">Pixel limit (×1000)</label><output id="limitVal">600</output></div>
        <input id="limit" type="range" min="20" max="5000" value="600" step="20">
        <div class="row" style="grid-template-columns:auto auto 1fr;">
          <button id="clearActive">Clear active layer</button>
          <button id="syncLayerStyle">Apply defaults to active layer</button>
        </div>
      </div>

      <div>
        <h2>Zoom & Pan</h2>
        <div class="row"><label for="zoom">Zoom</label><output id="zoomVal">100%</output></div>
        <input id="zoom" type="range" min="10" max="300" value="100" step="1">
        <div class="hint" id="meta"></div>
      </div>
    </section>

    <section id="tab-layers" class="tabpane">
      <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px;">
        <button id="addLayer">+ Layer</button>
        <button id="delLayer">Delete</button>
        <button id="dupLayer">Duplicate</button>
      </div>
      <div class="layerList" id="layerList"></div>
      <div class="hint">Tips: click a layer row to activate it. Eye toggles visibility. Color/opacity affect rendering.</div>
    </section>

    <section id="tab-symbols" class="tabpane">
      <div>
        <h2>Palette (drag onto canvas)</h2>
        <div class="palette" id="palette"></div>
        <div class="hint">Drag one of the symbols onto the canvas. Click to select; drag to move; <span class="kbd">Delete</span> to remove; <span class="kbd">[</span>/<span class="kbd">]</span> to rotate; <span class="kbd">+</span>/<span class="kbd">-</span> to scale.</div>
      </div>
      <div class="sep"></div>
      <div>
        <h2>Placement</h2>
        <label style="display:flex;gap:8px;align-items:center;"><input id="snapGrid" type="checkbox" checked> Snap to grid</label>
        <div class="row"><label for="gridSize">Grid size (px)</label><output id="gridSizeVal">10</output></div>
        <input id="gridSize" type="range" min="4" max="40" step="1" value="10">
        <label style="display:flex;gap:8px;align-items:center;"><input id="snapLine" type="checkbox"> Snap to existing lines</label>
        <label style="display:flex;gap:8px;align-items:center;"><input type="checkbox" id="symLockLayer"> Lock moves to active layer</label>
      </div>
      <div class="sep"></div>
      <div>
        <h2>Selected symbol</h2>
        <div class="row"><label for="symSize">Size (px)</label><output id="symSizeVal">64</output></div>
        <input id="symSize" type="range" min="20" max="200" value="64" step="2">
        <div class="row" style="grid-template-columns:auto auto auto 1fr; gap:8px;">
          <button id="rotL">⟲ Rotate</button>
          <button id="rotR">⟳ Rotate</button>
          <button id="delSym">Delete</button>
        </div>
        <div class="row"><label>Symbol color</label><input id="symColor" type="color" value="#000000"></div>
        <div class="row"><label>Label text</label><input id="symLabel" type="text" placeholder="e.g., R1"></div>
        <div class="row"><label>Label size (px)</label><output id="symLabelSizeVal">16</output></div>
        <input id="symLabelSize" type="range" min="10" max="36" step="1" value="16">
        <div class="row"><label>Label color</label><input id="symLabelColor" type="color" value="#000000"></div>
      </div>
    </section>

    <section id="tab-nets" class="tabpane">
<!-- Patch: Arrows & Label (pinned at top of Nets) -->
<div id="arrowsControlsPinned" class="net-chev-controls">
  <div class="hdr">Arrows &amp; Label</div>

  <div class="row toggles">
    <label><input type="checkbox" id="chkChevronEnable" checked> Arrows</label>
    <label><input type="checkbox" id="chkChevronMarch" checked> Marching</label>
    <label><input type="checkbox" id="chkLabelShow" checked> Label at start</label>
  </div>
  <div class="grid3">
    <div>Spacing</div><input type="range" id="rngChevronSpace" min="16" max="160" value="52"><output id="outChevronSpace">52</output>
    <div>Arrow Size</div><input type="range" id="rngChevronSize" min="10" max="48" value="18"><output id="outChevronSize">18</output>
    <div>Speed</div><input type="range" id="rngChevronSpeed" min="0" max="4" value="2"><output id="outChevronSpeed">2</output>
    <div>Label Size</div><input type="range" id="rngLabelSize" min="10" max="28" value="14"><output id="outLabelSize">14</output>
  </div>
  <div class="grid3">
    <div>Style</div>
    <select id="selArrowStyle">
      <option value="triangle" selected>Triangle</option>
      <option value="chevron">Chevron “»”</option>
      <option value="dots">Dots</option>
    </select>
    <span></span>
    <div>Start Offset</div><input type="range" id="rngStartOffset" min="0" max="120" value="12"><output id="outStartOffset">12</output>
    <div>Auto Density</div><label><input type="checkbox" id="chkAutoDensity" checked> Tight bends = denser arrows</label><span></span>
  </div>
  <div class="grid2">
    <div>Arrow Color</div><input type="color" id="colArrow" value="#6bb2ff">
    <div>Label BG</div><input type="color" id="colLabelBg" value="#141820">
    <div>Label Text</div><input type="color" id="colLabelFg" value="#e8eef7">
  </div>
  <div class="row" style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
    <label style="display:flex; align-items:center; gap:6px;"><input type="checkbox" id="chkAutoFromHighlight" checked> <span>Auto from highlight</span></label>
    <button id="btnApplyFromHighlight">Apply now</button>
    <button id="btnTestArrows">▶ Test arrows</button>
  </div>
</div>

      <div class="row" style="grid-template-columns:auto auto 1fr auto; gap:8px;">
        <button id="addNet">+ Net</button>
        <button id="delNet">Delete</button>
        <div></div>
        <button id="exportNets">Export JSON</button>
      </div>
      <div class="layerList" id="netsList"></div>
      <div class="hint">Click a net to edit. “+ Net” switches to Net Label mode; then click a wire to create it. Use the Zoom button on a row to center on that net.</div>
    </section>
    <section id="tab-cleanup" class="tabpane">
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupEnabled"> Enable cleanup overlay</label>
      </div>
      <div class="group">
        <label class="inline">Stroke thickness <input type="range" id="cleanupThickness" min="0.5" max="12" step="0.25" value="0.75"></label>
        <span id="cleanupThicknessVal">0.75 px</span>
      </div>
      <div class="group">
        <label class="inline">Bridge gaps (blur px) <input type="range" id="cleanupBridge" min="0" max="6" step="0.25" value="0.5"></label>
        <span id="cleanupBridgeVal">0.5 px</span>
      </div>
      <div class="row" style="gap:6px; flex-wrap:wrap">
        <span class="muted" style="opacity:.85">Presets:</span>
        <button class="chip" id="cleanupPresetFine" title="0.75 px / 0.5 px">Fine</button>
        <button class="chip" id="cleanupPresetNormal" title="1.5 px / 1.0 px">Normal</button>
        <button class="chip" id="cleanupPresetBold" title="2.5 px / 1.5 px">Bold</button>
      </div>
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupAuto" checked> Auto after trace</label>
      </div>
      <div class="group">
        <label class="inline"><input type="checkbox" id="cleanupIgnoreSymbols"> Ignore symbols while cleaning</label>
      </div>
      <div class="row" style="gap:8px;">
        <button id="cleanupRunNow">Run cleanup now</button>
        <button id="cleanupFindBtn">Find Opens/Tees</button>
        <button id="cleanupClearMarkers" title="Clear markers">Clear markers</button>
      </div>
      <div class="group" style="margin-top:8px;">
        <label class="inline"><input type="checkbox" id="junctionNormalize"> Normalize junction dots</label>
      </div>
      <div class="group">
        <label class="inline">Dot radius <input type="range" id="junctionRadius" min="2" max="14" step="0.5" value="6"></label>
        <span id="junctionRadiusVal">6 px</span>
      </div>

      <p class="muted">Cleanup draws a constant-thickness black stroke along traced masks, bridging tiny gaps and painting over symbols/text.</p>
    </section>
    <section id="tab-text" class="tabpane">
      <h2>Text cleanup</h2>
      <div class="group">
        <label class="inline"><input type="checkbox" id="textCleanEnabled" checked> Enable text-only cleanup</label>
      </div>
      <div class="group">
        <label class="inline">Tile size <input type="range" id="textTile" min="12" max="64" step="4" value="28"></label>
        <span id="textTileVal">28 px</span>
      </div>
      <div class="group">
        <label class="inline">Local offset (C) <input type="range" id="textC" min="0" max="40" step="1" value="12"></label>
        <span id="textCVal">12</span>
      </div>
      <div class="group">
        <label class="inline">Close radius <input type="range" id="textClose" min="0" max="2" step="0.25" value="0.5"></label>
        <span id="textCloseVal">0.5 px</span>
      </div>
      <div class="group">
        <label class="inline">Despeckle (neighbors) <input type="range" id="textSpeckle" min="0" max="4" step="1" value="2"></label>
        <span id="textSpeckleVal">2</span>
      </div>
      <div class="group">
        <label class="inline">Exclude traced lines <input type="checkbox" id="textExcludeLines" checked></label>
      </div>
      <div class="row" style="gap:8px;">
        <button id="textBuildBtn">Run Now</button>
        <button id="textClearBtn">Clear</button>
      </div>
      <p class="muted">      <div class="row" style="gap:8px; margin-top:8px;">
        <button id="ocrSelectBtn" title="Drag a box to OCR (O)">OCR selection</button>
        <button id="ocrPageBtn" title="OCR the entire image (slower)">OCR page</button>
        <label class="inline" style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="ocrAttachNet" checked> Attach OCR near wires as Net Label
        </label>
      </div>
This pass cleans only raster text: adaptive binarize, close tiny gaps, drop speckle, and draw crisp black text over a white underlay. Use “Retype (R)” to replace text manually.</p>
      <h3 style="margin-top:10px;">Retype patches</h3>
      <div class="row" style="gap:8px;">
        <button id="retypeToggle2">Retype Mode</button>
        <button id="clearRetypePatches">Clear Patches</button>
      </div>
    </section>


  </aside>

  <div id="splitBottom" class="splitter h">

    <button id="chevBottomSplit" class="chev chev-bottom" title="Hide bottom panel" aria-label="Hide bottom panel" style="left:50%; top:50%; transform:translate(-50%,-50%); height:22px; width:36px;"><span class="arrow"><svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg></span></button>
</div>
  <section id="bottomPanel" class="panel">
  <button id="chevBottom" class="chev chev-bottom" title="Hide bottom panel" aria-label="Hide bottom panel"><span class="arrow"><svg viewBox="0 0 24 24"><polyline points="6 10 12 16 18 10"/></svg></span></button>
    <div class="tabs" id="bottomTabs">
      <button data-tab="history" class="active">History</button>
      <button data-tab="console">Console</button>
      <button data-tab="tests">Self-tests</button>
    </div>
    <div class="sep"></div>

    <section id="tab-history" class="tabpane active">
      <div class="row" style="grid-template-columns:auto 1fr;gap:8px;align-items:center;">
        <h2 style="margin:0;">History</h2>
        <div style="text-align:right;"><button id="clearHistory">Clear history</button></div>
      </div>
      <div id="historyList"></div>
    </section>

    <section id="tab-console" class="tabpane">
      <div class="row" style="grid-template-columns:1fr auto;gap:8px;">
        <input id="consoleIn" placeholder="Type a command (help, clear, stats, layers, symbols, nets)" />
        <button id="consoleRun">Run</button>
      </div>
      <pre id="consoleOut"></pre>
    </section>

    <section id="tab-tests" class="tabpane">
      <div class="row" style="grid-template-columns:auto 1fr;gap:8px;align-items:center;">
        <h2 style="margin:0;">Self-tests</h2>
        <div style="text-align:right;"><button id="runTests">Run self-test</button></div>
      </div>
      <div class="hint">Quick check that tracing + overlay + autos are working.</div>
      <div id="testLog"></div>
    </section>
  </section>
</div>

<script src="js/state.js"></script>
<script src="js/tools.js"></script>
<script src="js/canvas.js"></script>
<script src="js/ui.js"></script>
<script src="js/main.js"></script>

</body>
</html>
    const n=Math.ceil((total-base)/space);
    for(let i=0;i<n;i++){ const P=sampleAt(pathScr, base+i*space); if(!P) break;
      if(S.style==='triangle') drawTriangle(actx,P.x,P.y,P.theta,S.size,S.colArrow);
      else if(S.style==='chevron') drawChevronShape(actx,P.x,P.y,P.theta,S.size,S.colArrow);
      else drawDot(actx,P.x,P.y,P.theta,S.size,S.colArrow);
    }
    if(S.labelShow){
      let labelText='NET';
      try{ if(typeof activeNet!=='undefined' && activeNet>=0 && netLabels && netLabels[activeNet] && netLabels[activeNet].name){ labelText = netLabels[activeNet].name || 'NET'; } }catch(_){}
      drawLabel(actx, pathScr, labelText, S.labelSize, S.colLabelBg, S.colLabelFg);
    }
    state.needsRedraw=false;
  }
  let rafId=null,lastT=0;
  function onFrame(t){ rafId=null; const S=readSettings(); const dt=Math.max(0,Math.min(100,t-(lastT||t)))/1000; lastT=t; const pxps = S.speed*60; if(state.anim && pxps>0){ state.offset=(state.offset+dt*pxps)%Math.max(1,(state.totalLen||1000)); state.needsRedraw=true; } drawFrame(); if(state.anim && (S.march && S.enable)) rafId=requestAnimationFrame(onFrame); }
  function startAnim(){ const S=readSettings(); const need=!!(S.march && S.enable); if(need && !rafId){ state.anim=true; lastT=0; rafId=requestAnimationFrame(onFrame);} else if(!need && rafId){ state.anim=false; cancelAnimationFrame(rafId); rafId=null; drawFrame(); } }
  window.__arrows_setPath = function(pathImg){
  try{
    const en = document.getElementById('chkChevronEnable');
    if(en) en.checked = true;
    if(typeof activeNet!=='undefined' && activeNet>=0 && netLabels[activeNet]){
      netLabels[activeNet].arrow = netLabels[activeNet].arrow || {};
      netLabels[activeNet].arrow.enable = true;
      if(netLabels[activeNet].arrow.march){ window.__setArrowAnimActive?.(true); }
    }
  }catch(_){}
 if(!Array.isArray(pathImg)||pathImg.length<2) return; state.pathImg=pathImg.slice(); state.totalLen=0; state.offset=0; state.needsRedraw=true; drawFrame(); startAnim(); };
  window.__setArrowAnimActive = function(on){ if(UI?.march){ UI.march.checked = !!on; } state.anim = !!on; startAnim(); };
  const controls = ['chkChevronEnable','chkChevronMarch','chkLabelShow','rngChevronSpace','rngChevronSize','rngChevronSpeed','rngLabelSize','selArrowStyle','rngStartOffset','chkAutoDensity','colArrow','colLabelBg','colLabelFg'];
  controls.forEach(id=> q(id)?.addEventListener('input', ()=>{ state.needsRedraw=true; drawFrame(); startAnim(); }));
  const _drawBase = drawBase; drawBase = function(){ _drawBase(); state.needsRedraw=true; drawFrame(); };
  const _redrawOverlay = redrawOverlay; redrawOverlay = function(){ _redrawOverlay(); state.needsRedraw=true; drawFrame(); };
  const _setCanvasSizeToContainer = setCanvasSizeToContainer; setCanvasSizeToContainer = function(){ _setCanvasSizeToContainer(); state.needsRedraw=true; drawFrame(); };
})(); // ===== /Manual Arrows Engine =====

</script>

<script>
/* ===============================================================
   Cleanup v3f — invert toggle + prefer H/V + robust single-run
   =============================================================== */
(function(){
  // -------- helpers to access app globals even if declared with let --------
  const G = {
    get imgLoaded(){ try{ return imgLoaded; }catch(e){ return window.imgLoaded; } },
    get rawImageData(){ try{ return rawImageData; }catch(e){ return window.rawImageData; } },
    get imgW(){ try{ return imgW; }catch(e){ return window.imgW; } },
    get imgH(){ try{ return imgH; }catch(e){ return window.imgH; } },
    get viewScale(){ try{ return viewScale; }catch(e){ return window.viewScale; } },
    get octx(){ try{ return octx; }catch(e){ return window.octx; } },
    get ctx(){ try{ return ctx; }catch(e){ return window.ctx; } },
    get redrawOverlay(){ try{ return redrawOverlay; }catch(e){ return window.redrawOverlay; } },
    get logHistory(){ try{ return logHistory; }catch(e){ return window.logHistory; } },
    get applyViewTransform(){ try{ return applyViewTransform; }catch(e){ return window.applyViewTransform; } },
  };

  // -------- locate Cleanup panel and add UI toggles --------
  function $(id){ return document.getElementById(id); }
  function addToggleRow(){
    // try to place toggles under bridge slider or above Run button
    const bridge = $('cleanupBridge');
    const runBtn = $('cleanupRunNow');
    const anchor = bridge?.parentElement || runBtn?.parentElement || document.body;

    const box = document.createElement('div');
    box.id = 'cleanupAdvancedRow';
    box.style.display = 'grid';
    box.style.gridTemplateColumns = 'repeat(3, auto)';
    box.style.gap = '8px';
    box.style.alignItems = 'center';
    box.style.marginTop = '6px';

    function mk(labelText, id){
      const wrap = document.createElement('label');
      wrap.style.display='inline-flex';
      wrap.style.alignItems='center';
      wrap.style.gap='6px';
      const cb = document.createElement('input');
      cb.type='checkbox'; cb.id=id;
      const sp = document.createElement('span');
      sp.textContent = labelText;
      wrap.appendChild(cb); wrap.appendChild(sp);
      return wrap;
    }

    // Create: Invert input, Prefer H lines, Prefer V lines
    box.appendChild(mk('Invert input', 'cleanupInvert'));
    box.appendChild(mk('Prefer H lines', 'cleanupPreferH'));
    box.appendChild(mk('Prefer V lines', 'cleanupPreferV'));

    // Avoid duplicates
    if (!$('cleanupAdvancedRow')){
      (anchor).appendChild(box);
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', addToggleRow);
  } else addToggleRow();

  // -------- Engine state --------
  const enabledEl  = $('cleanupEnabled');
  const thickEl    = $('cleanupThickness');
  const bridgeEl   = $('cleanupBridge');
  const invertEl   = $('cleanupInvert');
  const prefHEl    = $('cleanupPreferH');
  const prefVEl    = $('cleanupPreferV');
  const runBtn     = $('cleanupRunNow');
  const clearBtn   = $('cleanupClearMarkers');

  let H = []; // horizontal segments [{y,x0,x1}]
  let V = []; // vertical   segments [{x,y0,y1}]
  let running=false, lastRun=0;

  // -------- Overlay drawing --------
  window.drawCleanupOverlay = function(ctx){
    try{
      if (!G.imgLoaded || !enabledEl?.checked) return;
      if (H.length===0 && V.length===0) return;

      ctx.save();
      if (typeof G.applyViewTransform === 'function') G.applyViewTransform(ctx);

      const tUI = Number(thickEl?.value || 1.4);
      const scale = 1/Math.max(0.001, (G.viewScale||1));
      const lw = tUI*scale;
      const under = (tUI + 1.0 + Number(bridgeEl?.value||0))*scale;

      ctx.lineCap='round'; ctx.lineJoin='round';

      // undercoat
      ctx.globalCompositeOperation='source-over';
      ctx.strokeStyle='#ffffff';
      ctx.lineWidth=under;
      for (const s of H){ ctx.beginPath(); ctx.moveTo(s.x0 - G.imgW/2, s.y - G.imgH/2); ctx.lineTo(s.x1 - G.imgW/2, s.y - G.imgH/2); ctx.stroke(); }
      for (const s of V){ ctx.beginPath(); ctx.moveTo(s.x - G.imgW/2, s.y0 - G.imgH/2); ctx.lineTo(s.x - G.imgW/2, s.y1 - G.imgH/2); ctx.stroke(); }

      // black ink
      ctx.strokeStyle='#000000';
      ctx.lineWidth=lw;
      for (const s of H){ ctx.beginPath(); ctx.moveTo(s.x0 - G.imgW/2, s.y - G.imgH/2); ctx.lineTo(s.x1 - G.imgW/2, s.y - G.imgH/2); ctx.stroke(); }
      for (const s of V){ ctx.beginPath(); ctx.moveTo(s.x - G.imgW/2, s.y0 - G.imgH/2); ctx.lineTo(s.x - G.imgW/2, s.y1 - G.imgH/2); ctx.stroke(); }

      ctx.restore();
    }catch(e){ console.warn('drawCleanupOverlay error', e); }
  };

  // -------- Runner (debounced) --------
  window.__cleanupV3_run = async function(){
    const now = performance.now();
    if (running || (now - lastRun) < 250) return;
    running = true; lastRun = now;
    try{
      G.logHistory?.('[cleanup] starting…');

      // Grayscale
      const g = toGray(G.rawImageData, G.imgW, G.imgH);

      // Threshold (adaptive Bradley)
      const bin = adaptiveBradley(g, G.imgW, G.imgH, 31, 0.15);

      // Optional invert
      if (invertEl?.checked){
        for (let i=0;i<bin.length;i++) bin[i] = bin[i]?0:1;
      }

      // Despeckle
      despeckle(bin, G.imgW, G.imgH);

      // Long-run keeper with preference bias
      const baseL = Math.max(4, 4 + Math.round(Number(bridgeEl?.value||0)*2));
      let Lh = baseL, Lv = baseL;
      const preferH = !!prefHEl?.checked, preferV = !!prefVEl?.checked;
      if (preferH && !preferV){ Lh = Math.max(2, baseL-2); Lv = baseL+2; }
      if (preferV && !preferH){ Lv = Math.max(2, baseL-2); Lh = baseL+2; }

      const keepH = keepLongRunsH(bin, G.imgW, G.imgH, Lh);
      const keepV = keepLongRunsV(bin, G.imgW, G.imgH, Lv);
      // merge masks
      const keep = new Uint8Array(G.imgW*G.imgH);
      for (let i=0;i<keep.length;i++) keep[i] = (keepH[i] | keepV[i]);

      // Extract segments
      const segsH = [];
      for (let y=0;y<G.imgH;y++){
        let x=0;
        while (x<G.imgW){
          while (x<G.imgW && !keep[y*G.imgW+x]) x++;
          const x0=x;
          while (x<G.imgW && keep[y*G.imgW+x]) x++;
          const x1=x-1;
          if (x1>=x0 && (x1-x0+1)>=Lh) segsH.push({y, x0, x1});
        }
      }
      const segsV = [];
      for (let x=0;x<G.imgW;x++){
        let y=0;
        while (y<G.imgH){
          while (y<G.imgH && !keep[y*G.imgW+x]) y++;
          const y0=y;
          while (y<G.imgH && keep[y*G.imgW+x]) y++;
          const y1=y-1;
          if (y1>=y0 && (y1-y0+1)>=Lv) segsV.push({x, y0, y1});
        }
      }

      H = mergeColinearH(segsH, 2);
      V = mergeColinearV(segsV, 2);

      G.logHistory?.(`Cleanup v3f: H=${H.length} V=${V.length} (Lh=${Lh}, Lv=${Lv}) • ${(performance.now()-now|0)} ms`);

      // Turn on overlay so change is visible
      if (enabledEl && !enabledEl.checked){ enabledEl.checked = true; }

      G.redrawOverlay?.();
      G.logHistory?.('[cleanup] done.');
    }catch(e){
      console.error(e);
      G.logHistory?.('[cleanup] error — see console');
    }finally{
      running=false;
    }
  };

  // Click/clear bindings + shift+C + optional auto-run-on-load
  (function bind(){
    const runBtn = $('cleanupRunNow');
    const clearBtn = $('cleanupClearMarkers');
    runBtn?.addEventListener('click', (e)=>{ e.preventDefault(); __cleanupV3_run(); });
    clearBtn?.addEventListener('click', ()=>{ H.length=0; V.length=0; G.redrawOverlay?.(); });
    document.addEventListener('keydown', (e)=>{
      if (e.shiftKey && (e.key==='c'||e.key==='C')){ e.preventDefault(); __cleanupV3_run(); }
    });
    // Auto-run once if a "cleanup auto" checkbox exists and is checked
    let autoFired=false;
    const t = setInterval(()=>{
      try{
        if (G.imgLoaded){
          clearInterval(t);
          const auto = $('cleanupAuto') || $('cleanupAutoAfterTrace') || $('cleanupAutoRun');
          if (auto && (auto.checked || auto.getAttribute('data-default')==='true') && !autoFired){
            autoFired=true;
            G.logHistory?.('[cleanup] auto-run on image load');
            __cleanupV3_run();
          }
        }
      }catch(e){}
    }, 300);
  })();

  // Hook into redrawOverlay to render our overlay
  if (typeof G.redrawOverlay === 'function' && !window.__cleanupHookedV3f){
    const __orig = G.redrawOverlay;
    window.redrawOverlay = function(){
      try { __orig.apply(this, arguments); } finally {
        const ctx = (arguments[0] && arguments[0].canvas) ? arguments[0] : (G.octx || G.ctx || null);
        if (ctx) window.drawCleanupOverlay(ctx);
      }
    };
    window.__cleanupHookedV3f = true;
  }

  // ------------------- image ops -------------------
  function toGray(rgba,w,h){
    const src = rgba.data || rgba;
    const g = new Uint8Array(w*h);
    for (let i=0,j=0;i<g.length;i++,j+=4){
      g[i] = (0.2126*src[j] + 0.7152*src[j+1] + 0.0722*src[j+2])|0;
    }
    return g;
  }

  function adaptiveBradley(gray,w,h, win, t){
    const ii = new Uint32Array((w+1)*(h+1));
    for (let y=1;y<=h;y++){
      let rowsum=0;
      for (let x=1;x<=w;x++){
        const v = gray[(y-1)*w + (x-1)];
        rowsum += v;
        ii[y*(w+1)+x] = ii[(y-1)*(w+1)+x] + rowsum;
      }
    }
    const out = new Uint8Array(w*h);
    const half = Math.max(1, win>>1);
    for (let y=0;y<h;y++){
      const y0 = Math.max(0, y-half), y1 = Math.min(h-1, y+half);
      for (let x=0;x<w;x++){
        const x0 = Math.max(0, x-half), x1 = Math.min(w-1, x+half);
        const A = ii[y0*(w+1)+x0], B = ii[y0*(w+1)+(x1+1)];
        const C = ii[(y1+1)*(w+1)+x0], D = ii[(y1+1)*(w+1)+(x1+1)];
        const area = (x1-x0+1)*(y1-y0+1);
        const mean = (D - B - C + A) / area;
        const v = gray[y*w+x];
        out[y*w+x] = (v <= mean*(1 - t)) ? 1 : 0;
      }
    }
    return out;
  }

  function despeckle(img,w,h){
    const copy = img.slice(0);
    const idx=(x,y)=>y*w+x;
    const inb=(x,y)=> x>=0 && y>=0 && x<w && y<h;
    for (let y=1;y<h-1;y++){
      for (let x=1;x<w-1;x++){
        const i=idx(x,y);
        if (!copy[i]) continue;
        let s=0;
        for (let dy=-1;dy<=1;dy++){
          for (let dx=-1;dx<=1;dx++){
            if (!dx && !dy) continue;
            const xx=x+dx, yy=y+dy;
            if (inb(xx,yy)) s += copy[idx(xx,yy)];
          }
        }
        if (s<=1) img[i]=0;
      }
    }
  }

  function keepLongRunsH(bin,w,h,L){
    const out = new Uint8Array(w*h);
    for (let y=0;y<h;y++){
      let x=0;
      while (x<w){
        while (x<w && bin[y*w+x]===0) x++;
        const x0=x;
        while (x<w && bin[y*w+x]===1) x++;
        const x1=x-1, len=x1-x0+1;
        if (len>=L){ for (let X=x0; X<=x1; X++) out[y*w+X]=1; }
      }
    }
    return out;
  }
  function keepLongRunsV(bin,w,h,L){
    const out = new Uint8Array(w*h);
    for (let x=0;x<w;x++){
      let y=0;
      while (y<h){
        while (y<h && bin[y*w+x]===0) y++;
        const y0=y;
        while (y<h && bin[y*w+x]===1) y++;
        const y1=y-1, len=y1-y0+1;
        if (len>=L){ for (let Y=y0; Y<=y1; Y++) out[Y*w+x]=1; }
      }
    }
    return out;
  }

  function mergeColinearH(segs, gap){
    segs.sort((a,b)=> a.y-b.y || a.x0-b.x0);
    const out=[];
    for (const s of segs){
      const last = out[out.length-1];
      if (last && last.y===s.y && s.x0 <= last.x1 + gap) last.x1 = Math.max(last.x1, s.x1);
      else out.push({...s});
    }
    return out;
  }
  function mergeColinearV(segs, gap){
    segs.sort((a,b)=> a.x-b.x || a.y0-b.y0);
    const out=[];
    for (const s of segs){
      const last = out[out.length-1];
      if (last && last.x===s.x && s.y0 <= last.y1 + gap) last.y1 = Math.max(last.y1, s.y1);
      else out.push({...s});
    }
    return out;
  }
})();
</script>

<script>
// === One-click "Scan Polish" preset ===
(function(){
  function safe(fn){ try{ return fn&&fn(); }catch(_){ } }
  function show(title,text){ 
    const m=document.getElementById('progressModal'); if(!m) return; 
    m.style.display='flex';
    const t=document.getElementById('progressTitle'); if(t) t.textContent=title||'Working…';
    const p=document.getElementById('progressText'); if(p) p.textContent=text||'';
    const b=document.getElementById('progressBarFill'); if(b) b.style.width='0%';
  }
  function step(pct,text){
    const p=document.getElementById('progressText'); if(p&&text) p.textContent=text;
    const b=document.getElementById('progressBarFill'); if(b) b.style.width=Math.max(0,Math.min(100,pct|0))+'%';
  }
  function hide(){ const m=document.getElementById('progressModal'); if(m) m.style.display='none'; }

  async function runScanPolishPreset(){
    try{
      if(!window.__imgReady){ alert('Load an image first.'); return; }
      show('Scan Polish','Analyzing…'); await new Promise(r=>requestAnimationFrame(r));

      // 1) Auto threshold
      try{
        const chk=document.getElementById('autoThresh'); if(chk) chk.checked=true;
        document.getElementById('analyze')?.click();
        step(30,'Auto threshold set');
      }catch(_){}

      // 2) Cleanup
      try{
        const en=document.getElementById('cleanupEnabled'); if(en && !en.checked) en.click();
        const th=document.getElementById('cleanupThickness'); const br=document.getElementById('cleanupBridge');
        const thv=document.getElementById('cleanupThicknessVal'); const brv=document.getElementById('cleanupBridgeVal');
        if(th){ th.value=0.75; if(thv) thv.textContent='0.75 px'; }
        if(br){ br.value=0.5;  if(brv) brv.textContent='0.5 px'; }
        safe(window.syncCleanupUI);
        step(55,'Cleanup…');
        if(typeof window.runCleanupWithProgress==='function'){ await window.runCleanupWithProgress(); }
        else if(typeof window.__cleanupV3_run==='function'){ window.__cleanupV3_run(); }
        else { safe(window.redrawOverlay); }
      }catch(_){}

      // 3) Text cleanup
      try{
        const tOn=document.getElementById('textCleanEnabled'); if(tOn) tOn.checked=true;
        step(80,'Text cleanup…');
        if(typeof window.runTextCleanupWithProgress==='function'){ await window.runTextCleanupWithProgress(); }
        else if(typeof window.buildTextCleanup==='function'){ window.buildTextCleanup(); safe(window.redrawOverlay); }
      }catch(_){}

      // 4) Auto-label VCC/GND from annotations
      try{
        step(95,'Auto-label power nets…');
        (function autoLabel(){
          const anns = window.annotations||[]; const have=new Set((window.netLabels||[]).map(n=>(n?.name||'').toUpperCase()));
          const targets=['VCC','GND']; let added=0;
          for(const a of anns){
            const t=(a?.text||'').trim().toUpperCase();
            if(targets.includes(t) && !have.has(t)){
              if(typeof window.labelNetAt==='function'){ window.labelNetAt(a.x,a.y,t); have.add(t); added++; }
            }
          }
          if(added>0){ safe(window.refreshNetsList); safe(window.redrawOverlay); }
        })();
      }catch(_){}

      step(100,'Done');
      safe(()=>window.logHistory?.('[preset] Scan Polish completed'));
    } finally {
      setTimeout(hide, 120);
      safe(window.redrawOverlay);
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    // mark readiness when image loads (patch ingestBitmap)
    if(typeof window.ingestBitmap==='function' && !window.ingestBitmap.__patchedReady){
      const __orig = window.ingestBitmap;
      window.ingestBitmap = function(){
        const r = __orig.apply(this, arguments);
        window.__imgReady = true;
        return r;
      };
      window.ingestBitmap.__patchedReady = true;
    }
    const b=document.getElementById('scanPolishBtn'); if(b) b.addEventListener('click', runScanPolishPreset);
  });
})();
</script>



<script>
// === Find Opens/Tees v3 (clustered ring logic; fewer false tees; robust readiness) ===
(function(){
  // Mark readiness when an image is ingested
  document.addEventListener('DOMContentLoaded', ()=>{
    if(typeof window.ingestBitmap==='function' && !window.ingestBitmap.__patchedReady3){
      const __orig = window.ingestBitmap;
      window.ingestBitmap = function(){
        const r = __orig.apply(this, arguments);
        window.__imgReady = true;
        return r;
      };
      window.ingestBitmap.__patchedReady3 = true;
    }
  });

  function isReady(){ return !!window.__imgReady; }

  // Ring-cluster classifier on IMAGE coords
  function countRingClusters(ix,iy,threshold){
    const ring = [[0,0,0],[0,0,0],[0,0,0]];
    let neighborCount = 0;
    for(let dy=-1; dy<=1; dy++){
      for(let dx=-1; dx<=1; dx++){
        if(dx===0 && dy===0) continue;
        const nx = ix+dx, ny = iy+dy;
        if(nx<0||ny<0||nx>=imgW||ny>=imgH) continue;
        if(isInk(nx,ny,threshold)){ ring[dy+1][dx+1] = 1; neighborCount++; }
      }
    }
    // Connected components on the 3x3 ring (8-connectivity)
    let comps=0;
    const seen=[[0,0,0],[0,0,0],[0,0,0]];
    const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
    function flood(i,j){
      const q=[[i,j]]; seen[i][j]=1;
      while(q.length){
        const [a,b]=q.shift();
        for(const [di,dj] of dirs){
          const ni=a+di, nj=b+dj;
          if(ni<0||nj<0||ni>2||nj>2) continue;
          if(!seen[ni][nj] && ring[ni][nj]){ seen[ni][nj]=1; q.push([ni,nj]); }
        }
      }
    }
    for(let i=0;i<3;i++){
      for(let j=0;j<3;j++){
        if(ring[i][j] && !seen[i][j]){ comps++; flood(i,j); }
      }
    }
    return { neighborCount, comps, ring };
  }

  function nearSymbol(ix,iy){
    try{
      if(!(window.cleanup?.ignoreSymbols)) return false;
      if(typeof hitTestSymbol!=='function') return false;
      return hitTestSymbol(ix,iy) >= 0;
    }catch(_){ return false; }
  }

  function clusterPoints(pts, radius){
    const out=[]; const r2=radius*radius;
    for(const p of pts){
      let found=false;
      for(const c of out){
        const dx=p.x-c.x, dy=p.y-c.y;
        if(dx*dx+dy*dy<=r2){
          c.x = (c.x*c.n + p.x)/(c.n+1);
          c.y = (c.y*c.n + p.y)/(c.n+1);
          c.n += 1; c.type = c.type || p.type;
          found=true; break;
        }
      }
      if(!found){ out.push({x:p.x, y:p.y, type:p.type, n:1}); }
    }
    return out.map(c=>({x:Math.round(c.x), y:Math.round(c.y), type:c.type}));
  }

  // Draw markers in SCREEN space (zoom-invariant)
  function drawMarkersScreen(ctx, markers){
    if(!markers || !markers.length) return;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    const s = 8;
    for(const m of markers){
      const pt = (typeof imgToScreen==='function') ? imgToScreen(m.x, m.y) : [m.x, m.y];
      const x = pt[0], y = pt[1];
      if(m.type==='end'){
        ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, s, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x-s*0.7,y-s*0.7); ctx.lineTo(x+s*0.7,y+s*0.7);
        ctx.moveTo(x-s*0.7,y+s*0.7); ctx.lineTo(x+s*0.7,y-s*0.7); ctx.stroke();
      } else {
        ctx.strokeStyle = '#6bb2ff'; ctx.lineWidth = 2;
        ctx.strokeRect(x-s, y-s, 2*s, 2*s);
        ctx.beginPath(); ctx.moveTo(x - s*0.9, y); ctx.lineTo(x + s*0.9, y);
        ctx.moveTo(x, y - s*0.9); ctx.lineTo(x, y + s*0.9); ctx.stroke();
      }
    }
    ctx.restore();
  }

  function findOpensAndTees_v3(){
    if(!isReady()){ alert('Load an image first.'); return; }
    const threshold = +((document.getElementById('thresh')||{}).value || 120);
    const cv = document.getElementById('view'); if(!cv) return;
    const ends=[], tees=[];

    // Sample visible region in SCREEN space, project to IMAGE coords
    const step = 2; // screen px stride
    for(let sy=1; sy<cv.height-1; sy+=step){
      for(let sx=1; sx<cv.width-1; sx+=step){
        const pix = screenToImg(sx, sy);
        const ix = (pix[0]|0), iy = (pix[1]|0);
        if(ix<1||iy<1||ix>=imgW-1||iy>=imgH-1) continue;
        if(typeof isInk!=='function' || !isInk(ix,iy,threshold)) continue;
        if(nearSymbol(ix,iy)) continue;

        const {neighborCount, comps} = countRingClusters(ix,iy,threshold);

        // Endpoint heuristic: 1 cluster with 1 neighbor (thin) or 2 neighbors but still 1 cluster (fatter line tips)
        if((neighborCount===1 && comps===1) || (neighborCount===2 && comps===1)){
          ends.push({x:ix, y:iy, type:'end'});
          continue;
        }

        // Tee/junction heuristic: at least 3 separated clusters (robust against fat 90° corners)
        if(comps>=3){
          tees.push({x:ix, y:iy, type:'tee'});
        }
      }
    }

    const endsC = clusterPoints(ends, 10);
    const teesC = clusterPoints(tees, 10);
    window.cleanupMarkers = [...teesC, ...endsC];
    try{ window.logHistory && window.logHistory(`Markers: ${teesC.length} tees, ${endsC.length} opens`); }catch(_){}
    try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
    return {tees: teesC.length, opens: endsC.length};
  }

  // (Removed) Global click capture for Find Opens/Tees to prevent double invocation.
  // Dedicated handlers are attached in initCleanupUI().

  // Ensure markers render after overlay
  const __redraw = window.redrawOverlay;
  window.redrawOverlay = function(){
    try{ __redraw && __redraw(); }catch(_){}
    try{
      const ctx = (window.octx || (document.getElementById('overlay')?.getContext('2d')));
      drawMarkersScreen(ctx, window.cleanupMarkers||[]);
    }catch(_){}
  };
})();
</script>


<script>
// === Junction Dot Normalizer
(function(){
  // State
  window.junctionCfg = window.junctionCfg || { enabled:false, radius:6 };

  function syncJunctionUI(){
    const en = document.getElementById('junctionNormalize');
    const ra = document.getElementById('junctionRadius');
    const rv = document.getElementById('junctionRadiusVal');
    if(!en || !ra || !rv) return;
    en.checked = !!window.junctionCfg.enabled;
    ra.value = +window.junctionCfg.radius || 6;
    rv.textContent = (Math.round((+ra.value)*10)/10) + ' px';
  }

  function hookUI(){
    const en = document.getElementById('junctionNormalize');
    const ra = document.getElementById('junctionRadius');
    const rv = document.getElementById('junctionRadiusVal');
    if(en){
      en.addEventListener('change', ()=>{
        window.junctionCfg.enabled = !!en.checked;
        try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
      });
    }
    if(ra && rv){
      ra.addEventListener('input', ()=>{
        window.junctionCfg.radius = +ra.value;
        rv.textContent = (Math.round((+ra.value)*10)/10) + ' px';
        try{ window.redrawOverlay && window.redrawOverlay(); }catch(_){}
      });
    }
    syncJunctionUI();
  }

  function ensureTeeMarkers(){
    if(Array.isArray(window.cleanupMarkers) && window.cleanupMarkers.some(m=>m.type==='tee')) return window.cleanupMarkers;
    try{
      if(typeof findOpensAndTees_v3==='function'){ findOpensAndTees_v3(); }
      else if(typeof findOpensAndTees_v2==='function'){ findOpensAndTees_v2(); }
    }catch(_){}
    return window.cleanupMarkers || [];
  }

  // Draw filled black circles at each tee; overlay uses SCREEN units
  function drawJunctionDots(ctx){
    if(!window.junctionCfg?.enabled) return;
    const r = Math.max(1, +window.junctionCfg.radius || 6);
    const markers = ensureTeeMarkers().filter(m=>m.type==='tee');
    if(!markers.length) return;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    for(const m of markers){
      const pt = (typeof imgToScreen==='function') ? imgToScreen(m.x, m.y) : [m.x, m.y];
      ctx.fillStyle = '#000000';
      ctx.beginPath();
      ctx.arc(pt[0], pt[1], r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.7)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }
  window.drawJunctionDots = drawJunctionDots;

  // Draw LAST: wrap the most recent redrawOverlay so dots are always on top
  const __prevRedraw = window.redrawOverlay;
  window.redrawOverlay = function(){
    try{ __prevRedraw && __prevRedraw(); }catch(_){}
    try{
      const ctx = (window.octx || (document.getElementById('overlay')?.getContext('2d')));
      drawJunctionDots(ctx);
    }catch(_){}
  };

  // Patch PNG export: scale radius from SCREEN px to IMAGE px using current viewScale
  if(typeof window.drawNetLabels==='function' && !window.drawNetLabels.__junctionExport2){
    const __origDrawNetLabels = window.drawNetLabels;
    window.drawNetLabels = function(ctx, transformed){
      const r = __origDrawNetLabels.apply(this, arguments);
      try{
        if(window.junctionCfg?.enabled && transformed===false){
          const markers = ensureTeeMarkers().filter(m=>m.type==='tee');
          const screenR = Math.max(1, +window.junctionCfg.radius || 6);
          const scale = (typeof window.viewScale==='number' && window.viewScale>0) ? window.viewScale : 1;
          const imgR = Math.max(1, Math.round(screenR / scale)); // convert to image pixels
          ctx.save();
          for(const m of markers){
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(m.x, m.y, imgR, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.restore();
        }
      }catch(_){}
      return r;
    };
    window.drawNetLabels.__junctionExport2 = true;
  }

  document.addEventListener('DOMContentLoaded', hookUI);
})();
</script>


<script>
// === OCR (Tesseract.js) — selection + full page =================================
(function(){
  let ocrWorker = null;
  let ocrSelectMode = false;
  let ocrRectEl = null;
  const ocrCfg = { attachNet: true };

  async function initOcr(){
    if(ocrWorker) return ocrWorker;
    if(!window.Tesseract){ alert('Tesseract.js not loaded.'); throw new Error('No Tesseract'); }
    ocrWorker = await Tesseract.createWorker('eng', 1, { logger: m => console.debug('[OCR]', m) });
    return ocrWorker;
  }

  function showProgress(title, text, prog){
    try{
      let modal = document.getElementById('progressModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id='progressModal';
        modal.innerHTML = '<div id="progressCard"><h3 id="progressTitle"></h3><div id="progressText"></div><div class="progressBar"><div id="progressFill"></div></div></div>';
        document.body.appendChild(modal);
      }
      const fill = modal.querySelector('#progressFill');
      modal.style.display='flex';
      modal.querySelector('#progressTitle').textContent = title||'Working…';
      modal.querySelector('#progressText').textContent = text||'';
      if(fill){ fill.style.width = (Math.max(0, Math.min(100, prog||0))) + '%'; fill.style.background = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#6bb2ff'; }
    }catch(e){ console.warn(e); }
  }
  function hideProgress(){
    const modal = document.getElementById('progressModal');
    if(modal) modal.style.display='none';
  }

  function getImageCropCanvas(ix, iy, w, h){
    const c = document.createElement('canvas');
    c.width = Math.max(1, w|0); c.height = Math.max(1, h|0);
    const cx = c.getContext('2d', { willReadFrequently:true });
    cx.drawImage(imgBitmap, ix, iy, w, h, 0, 0, c.width, c.height);
    return c;
  }

  function placeOcrLine(ix, iy, w, h, line){
    const text = (line.text||'').trim();
    if(!text) return;
    const cx = ix + (line.bbox?.x0||0) + ((line.bbox?.x1||0) - (line.bbox?.x0||0))/2;
    const cy = iy + (line.bbox?.y0||0) + ((line.bbox?.y1||0) - (line.bbox?.y0||0))/2;
    if( (document.getElementById('ocrAttachNet')?.checked) && typeof findNearestInkRobust==='function'){
      const hit = findNearestInkRobust(cx|0, cy|0, Math.max(8, (+snap?.value||6)), +thresh?.value||120);
      if(hit && typeof labelNetAt==='function'){
        try{ labelNetAt(hit.x, hit.y, text); return; }catch(_){}
      }
    }
    annotations.push({ x:cx, y:cy, text, size:+(labelSize?.value||18), color:(labelColor?.value||'#ffff00') });
  }

  async function ocrRect(ix, iy, w, h){
    if(!imgLoaded) return alert('Load an image first.');
    const worker = await initOcr();
    showProgress('OCR selection', 'Recognizing…', 10);
    const crop = getImageCropCanvas(ix, iy, w, h);
    const result = await worker.recognize(crop, { tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-_+/VΩkMμ%' });
    try{
      const lines = (result?.data?.lines)||[];
      for(const ln of lines){ placeOcrLine(ix, iy, w, h, ln); }
      redrawOverlay();
      logHistory?.(`OCR selection → ${ (result?.data?.text||'').trim().slice(0,60) }`);
    }finally{ hideProgress(); }
  }
  window.ocrRect = ocrRect;

  async function ocrPage(){
    if(!imgLoaded) return alert('Load an image first.');
    const worker = await initOcr();
    const tile = 900; const overlap = 40;
    let done = 0; const totalX = Math.ceil(imgW / (tile - overlap)); const totalY = Math.ceil(imgH / (tile - overlap));
    const total = totalX * totalY;
    for(let y=0; y<imgH; y += (tile - overlap)){
      const h = Math.min(tile, imgH - y);
      for(let x=0; x<imgW; x += (tile - overlap)){
        const w = Math.min(tile, imgW - x);
        showProgress('OCR page', `Tile ${done+1}/${total}`, (done/total)*100);
        const crop = getImageCropCanvas(x, y, w, h);
        const result = await worker.recognize(crop, { tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-_+/VΩkMμ%' });
        const lines = (result?.data?.lines)||[];
        for(const ln of lines){ placeOcrLine(x, y, w, h, ln); }
        done++;
      }
    }
    hideProgress();
    redrawOverlay();
    logHistory?.(`OCR page complete (${done} tiles).`);
  }
  window.ocrPage = ocrPage;

  function enableOcrSelect(on){
    ocrSelectMode = !!on;
    if(ocrSelectMode){
      if(!ocrRectEl){
        ocrRectEl = document.createElement('div');
        ocrRectEl.className = 'retype-rect';
        ocrRectEl.style.display = 'none';
        document.querySelector('.canvasWrap')?.appendChild(ocrRectEl);
      }
      logHistory?.('OCR selection: drag a box on the canvas.');
    } else {
      if(ocrRectEl) ocrRectEl.style.display = 'none';
    }
  }

  const ocrSelectBtn = document.getElementById('ocrSelectBtn');
  const ocrPageBtn = document.getElementById('ocrPageBtn');
  ocrSelectBtn?.addEventListener('click', ()=> enableOcrSelect(!ocrSelectMode));
  ocrPageBtn?.addEventListener('click', ()=> ocrPage());

  window.addEventListener('keydown', (e)=>{
    const tgt = e.target; const typing = tgt && (tgt.tagName==='INPUT' || tgt.tagName==='TEXTAREA' || tgt.isContentEditable);
    if(!typing && (e.key==='o' || e.key==='O')){
      e.preventDefault();
      enableOcrSelect(!ocrSelectMode);
    }
  });

  let dragStart = null;
  const viewEl = document.getElementById('view');
  function onDown(e){
    if(!ocrSelectMode) return;
    e.preventDefault(); e.stopPropagation();
    dragStart = { sx: e.offsetX, sy: e.offsetY };
    ocrRectEl.style.left = `${dragStart.sx}px`;
    ocrRectEl.style.top  = `${dragStart.sy}px`;
    ocrRectEl.style.width = '1px'; ocrRectEl.style.height='1px';
    ocrRectEl.style.display = 'block';
  }
  function onMove(e){
    if(!dragStart || !ocrSelectMode) return;
    const x1 = Math.min(dragStart.sx, e.offsetX), y1 = Math.min(dragStart.sy, e.offsetY);
    const x2 = Math.max(dragStart.sx, e.offsetX), y2 = Math.max(dragStart.sy, e.offsetY);
    ocrRectEl.style.left = `${x1}px`; ocrRectEl.style.top = `${y1}px`;
    ocrRectEl.style.width = `${x2-x1}px`; ocrRectEl.style.height = `${y2-y1}px`;
  }
  function onUp(e){
    if(!dragStart || !ocrSelectMode) return;
    const x1 = Math.min(dragStart.sx, e.offsetX), y1 = Math.min(dragStart.sy, e.offsetY);
    const x2 = Math.max(dragStart.sx, e.offsetX), y2 = Math.max(dragStart.sy, e.offsetY);
    dragStart = null; ocrRectEl.style.display = 'none'; enableOcrSelect(false);
    const p1 = screenToImg(x1, y1);
    const p2 = screenToImg(x2, y2);
    const ix = Math.max(0, Math.min(imgW-1, Math.floor(Math.min(p1[0], p2[0]))));
    const iy = Math.max(0, Math.min(imgH-1, Math.floor(Math.min(p1[1], p2[1]))));
    const iw = Math.max(1, Math.floor(Math.abs(p2[0]-p1[0])));
    const ih = Math.max(1, Math.floor(Math.abs(p2[1]-p1[1])));
    ocrRect(ix, iy, iw, ih);
  }
  viewEl?.addEventListener('mousedown', onDown, true);
  viewEl?.addEventListener('mousemove', onMove, true);
  viewEl?.addEventListener('mouseup', onUp, true);

  window.addEventListener('beforeunload', ()=>{ try{ ocrWorker && ocrWorker.terminate && ocrWorker.terminate(); }catch(_){} });
})();
</script>
</body>

</html>
